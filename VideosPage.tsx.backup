import React, { useState, useEffect, useContext, useRef } from 'react'
import { useTranslation } from 'react-i18next'
import { toast } from 'sonner'
import { Card, CardContent } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { 
  Download, 
  Share2, 
  Trash2, 
  Eye, 
  Search,
  Grid,
  List,
  Plus,
  Calendar,
  Clock,
  TrendingUp,
  Loader2,
  ArrowRight,
  Layers
} from 'lucide-react'
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog'
import LazyVideoPlayer from '@/components/video/LazyVideoPlayer'
import EnhancedVideoCard from '@/components/video/EnhancedVideoCard'
import supabaseVideoService from '@/services/supabaseVideoService'
import videoShareService from '@/services/videoShareService'
import { progressManager } from '@/services/progressManager'
import type { VideoProgress } from '@/services/progressManager'
import { taskRecoveryService } from '@/services/taskRecoveryService'
import { videoPollingService } from '@/services/VideoPollingService'
import { videoTaskManager } from '@/services/VideoTaskManager'
import type { VideoTask } from '@/services/VideoTaskManager'
import { formatDuration } from '@/utils/timeFormat'
import { Link, useNavigate } from 'react-router-dom'
import { AuthContext } from '@/contexts/AuthContext'
import type { Database } from '@/lib/supabase'
import { templates } from '@/features/video-creator/data/templates'
import { formatRelativeTime } from '@/utils/timeFormat'
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip'

type Video = Database['public']['Tables']['videos']['Row']

export default function VideosPage() {
  const { t } = useTranslation()
  const authContext = useContext(AuthContext)
  const user = authContext?.user
  const navigate = useNavigate()
  // const [searchParams, setSearchParams] = useSearchParams() // æš‚æ—¶æœªä½¿ç”¨
  // é¿å…æœªä½¿ç”¨å˜é‡è­¦å‘Š
  // void useSearchParams
  
  // ğŸš€ æ€§èƒ½ç›‘æ§ï¼šè®°å½•é¡µé¢ç”Ÿå‘½å‘¨æœŸæ—¶é—´ç‚¹
  const performanceTimers = React.useRef({
    componentMount: performance.now(),
    firstRender: 0,
    dataLoaded: 0,
    fullyInteractive: 0,
    taskRecoveryComplete: 0
  })
  
  // åœ¨ç»„ä»¶é¦–æ¬¡æ¸²æŸ“æ—¶è®°å½•æ—¶é—´
  React.useEffect(() => {
    if (performanceTimers.current.firstRender === 0) {
      performanceTimers.current.firstRender = performance.now()
      const renderTime = performanceTimers.current.firstRender - performanceTimers.current.componentMount
      console.log(`[PERF] ğŸ“Š VideosPage é¦–æ¬¡æ¸²æŸ“å®Œæˆ: ${Math.round(renderTime)}ms`)
    }
  }, [])
  
  console.log(`[PERF] ğŸ¬ VideosPage ç»„ä»¶å¼€å§‹æ¸²æŸ“ - ${new Date().toISOString()}`)
  
  // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šåˆå¹¶æ¨¡æ€æ¡†ç›¸å…³çŠ¶æ€ï¼Œå‡å°‘é‡æ¸²æŸ“
  const [modals, setModals] = useState({
    videoPlayer: { open: false, video: null as Video | null },
    share: { open: false, video: null as Video | null },
    delete: { open: false, video: null as Video | null }
  })
  
  // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šåˆå¹¶UIçŠ¶æ€
  const [uiState, setUiState] = useState({
    viewMode: 'grid' as 'grid' | 'list',
    filter: {} as any,
    searchTerm: '',
    loading: true,
    page: 1,
    totalPages: 1
  })
  
  // æ ¸å¿ƒæ•°æ®çŠ¶æ€ï¼ˆä¿æŒç‹¬ç«‹ä»¥ä¼˜åŒ–æ¸²æŸ“ï¼‰
  const [videos, setVideos] = useState<Video[]>([])
  const [filteredVideos, setFilteredVideos] = useState<Video[]>([])
  const [statistics, setStatistics] = useState<any>(null)
  const [completionNotification, setCompletionNotification] = useState<{
    visible: boolean
    video: Video | null
  }>({ visible: false, video: null })
  const [videoProgress, setVideoProgress] = useState<Map<string, VideoProgress>>(new Map())
  const [taskRecovery, setTaskRecovery] = useState<{
    isRecovering: boolean
    restoredCount: number
    resumedCount: number
  }>({ isRecovering: false, restoredCount: 0, resumedCount: 0 })
  
  // é˜²æ­¢é‡å¤é€šçŸ¥çš„çŠ¶æ€
  const [notifiedVideos, setNotifiedVideos] = useState<Set<string>>(new Set())
  
  // ç®¡ç†å¹¿æ’­é¢‘é“ - ä½¿ç”¨Mapæ¥è·Ÿè¸ªvideoId -> channel
  const [broadcastChannels, setBroadcastChannels] = useState<Map<string, any>>(new Map())
  
  // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šç¼“å­˜æ¨¡æ¿æŸ¥æ‰¾ï¼Œé¿å…é‡å¤è®¡ç®—
  const templateMap = React.useMemo(() => {
    const map = new Map()
    templates.forEach(template => {
      map.set(template.id, template)
    })
    console.log(`[VideosPage] ğŸ“š æ¨¡æ¿æ˜ å°„ç¼“å­˜åˆ›å»ºï¼ŒåŒ…å« ${map.size} ä¸ªæ¨¡æ¿`, map)
    return map
  }, [])
  
  // é¿å…æœªä½¿ç”¨å˜é‡è­¦å‘Š
  void templateMap
  
  // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šç¼“å­˜äº‹ä»¶å¤„ç†å‡½æ•°ï¼Œé¿å…å­ç»„ä»¶é‡æ¸²æŸ“
  const handlePlayVideo = React.useCallback(async (video: Video) => {
    const interactionStart = performance.now()
    console.log(`[PERF] ğŸ¬ å¼€å§‹æ’­æ”¾è§†é¢‘: ${video.id}`)
    
    if (video.video_url) {
      setModals(prev => ({ 
        ...prev, 
        videoPlayer: { open: true, video }
      }))
      
      try {
        await supabaseVideoService.incrementInteraction(video.id, 'view_count')
        const interactionTime = performance.now() - interactionStart
        console.log(`[PERF] âœ… è§†é¢‘æ’­æ”¾äº¤äº’å®Œæˆ: ${Math.round(interactionTime)}ms`)
      } catch (error) {
        console.error(`[PERF] âŒ è§†é¢‘æ’­æ”¾äº¤äº’å¤±è´¥:`, error)
      }
    }
  }, [])
  
  const handleShareVideo = React.useCallback((video: Video) => {
    console.log(`[PERF] ğŸ“¤ æ‰“å¼€åˆ†äº«æ¨¡æ€æ¡†: ${video.id}`)
    const modalStart = performance.now()
    
    setModals(prev => ({ 
      ...prev, 
      share: { open: true, video }
    }))
    
    const modalTime = performance.now() - modalStart
    console.log(`[PERF] âœ… åˆ†äº«æ¨¡æ€æ¡†æ‰“å¼€: ${Math.round(modalTime)}ms`)
  }, [])
  
  const handleDeleteVideo = React.useCallback((video: Video) => {
    console.log(`[PERF] ğŸ—‘ï¸ æ‰“å¼€åˆ é™¤ç¡®è®¤: ${video.id}`)
    const deleteModalStart = performance.now()
    
    setModals(prev => ({ 
      ...prev, 
      delete: { open: true, video }
    }))
    
    const deleteModalTime = performance.now() - deleteModalStart
    console.log(`[PERF] âœ… åˆ é™¤ç¡®è®¤æ¨¡æ€æ¡†æ‰“å¼€: ${Math.round(deleteModalTime)}ms`)
  }, [])
  
  // ä½¿ç”¨useRefç®¡ç†è½®è¯¢ï¼Œé¿å…å¤šé‡interval
  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null)
  console.log('Poll interval ref:', pollIntervalRef.current)
  const lastKnownStatusRef = useRef<string | null>(null)
  
  // é¿å…æœªä½¿ç”¨å˜é‡è­¦å‘Š
  void lastKnownStatusRef
  
  // æ·»åŠ åˆå§‹åŒ–çŠ¶æ€ç®¡ç†ï¼Œé˜²æ­¢é‡å¤æ‰§è¡Œ
  const initializationRef = useRef<{
    isRecovering: boolean
    isTaskManagerInitialized: boolean
    currentUserId: string | null
  }>({
    isRecovering: false,
    isTaskManagerInitialized: false,
    currentUserId: null
  })

  // å¤„ç†è§†é¢‘æ›´æ–°çš„å‡½æ•°ï¼ˆç”¨äºå¹¿æ’­ç›‘å¬å™¨ï¼‰
  const handleVideoUpdate = (updatedVideo: Video) => {
    console.log('[VideosPage] ğŸ“¡ Received broadcast video update:', updatedVideo.id, updatedVideo.status)
    
    // æ›´æ–°è§†é¢‘åˆ—è¡¨ä¸­çš„å¯¹åº”è®°å½•
    setVideos(prev => prev.map(v => 
      v.id === updatedVideo.id ? updatedVideo : v
    ))
    
    // å¦‚æœè§†é¢‘å®Œæˆï¼Œæ¸…ç†è¿›åº¦æ•°æ®å¹¶æ˜¾ç¤ºé€šçŸ¥
    if (updatedVideo.status === 'completed') {
      // ç«‹å³æ¸…ç†è¿›åº¦æ•°æ®
      setVideoProgress(prev => {
        const newMap = new Map(prev)
        newMap.delete(updatedVideo.id)
        return newMap
      })
      console.log(`[VideosPage] ğŸ“¡ Broadcast: Video completed, cleared progress data: ${updatedVideo.id}`)
      
      // å¼ºåˆ¶UIé‡æ–°æ¸²æŸ“ï¼Œç¡®ä¿æ˜¾ç¤ºè§†é¢‘é¢„è§ˆ
      setTimeout(() => {
        setVideos(prev => prev.map(v => 
          v.id === updatedVideo.id ? { ...updatedVideo } : v
        ))
      }, 100)
      
      // æ˜¾ç¤ºå®Œæˆé€šçŸ¥
      showCompletionNotification(updatedVideo)
    }
    
    loadStatistics() // é‡æ–°åŠ è½½ç»Ÿè®¡
  }
  
  // é¿å…æœªä½¿ç”¨å˜é‡è­¦å‘Š
  void handleVideoUpdate
  

  useEffect(() => {
    if (user) {
      // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡æ–°åˆå§‹åŒ–ï¼ˆç”¨æˆ·åˆ‡æ¢æˆ–é¦–æ¬¡åŠ è½½ï¼‰
      const needsInitialization = !initializationRef.current.currentUserId || 
                                  initializationRef.current.currentUserId !== user.id
      
      console.log('[VideosPage] useEffectè§¦å‘:', { 
        userId: user.id, 
        needsInitialization, 
        currentUserId: initializationRef.current.currentUserId,
        isRecovering: initializationRef.current.isRecovering 
      })
      
      // ğŸš€ å…³é”®ä¼˜åŒ–ï¼šå¹¶è¡ŒåŠ è½½æ•°æ®ï¼Œå¿«é€Ÿæ˜¾ç¤ºé¡µé¢å†…å®¹
      console.log('[VideosPage] ğŸš€ å¯åŠ¨å¿«é€Ÿå¹¶è¡Œåˆå§‹åŒ–...')
      console.log(`[PERF] âš¡ å¹¶è¡Œåˆå§‹åŒ–å¼€å§‹æ—¶é—´: ${Math.round(performance.now() - performanceTimers.current.componentMount)}ms`)
      const quickInitStart = performance.now()
      
      // ç«‹å³å¹¶è¡ŒåŠ è½½å…³é”®æ•°æ®ï¼Œä¸ç­‰å¾…ä»»ä½•å…¶ä»–æ“ä½œ
      console.log(`[PERF] ğŸ”¥ å¼€å§‹å¹¶è¡Œè¯·æ±‚: è§†é¢‘æ•°æ® + ç»Ÿè®¡æ•°æ®`)
      Promise.all([
        loadVideos(),
        loadStatistics()
      ]).then(() => {
        const quickInitTime = performance.now() - quickInitStart
        const totalTimeFromMount = performance.now() - performanceTimers.current.componentMount
        
        console.log(`[PERF] âš¡ ========== å¿«é€Ÿåˆå§‹åŒ–å®Œæˆ ==========`)
        console.log(`[PERF] ğŸ“Š å¹¶è¡ŒåŠ è½½è€—æ—¶: ${Math.round(quickInitTime)}ms`)
        console.log(`[PERF] ğŸ¯ ä»ç»„ä»¶æŒ‚è½½åˆ°æ•°æ®åŠ è½½å®Œæˆ: ${Math.round(totalTimeFromMount)}ms`)
        console.log(`[PERF] âœ… é¡µé¢å†…å®¹ç°åœ¨å·²ç»å¯è§ï¼Œç”¨æˆ·å¯ä»¥äº¤äº’`)
        console.log(`[PERF] =======================================`)
        
        // é¡µé¢å†…å®¹ç°åœ¨å·²ç»å¯è§ï¼Œç”¨æˆ·å¯ä»¥äº¤äº’
      }).catch(error => {
        const quickInitTime = performance.now() - quickInitStart
        console.error(`[PERF] âŒ å¿«é€Ÿåˆå§‹åŒ–å¤±è´¥: ${Math.round(quickInitTime)}ms`, error)
      })
      
      // åªåœ¨éœ€è¦æ—¶æ‰§è¡Œä»»åŠ¡æ¢å¤ - åœ¨åå°å¼‚æ­¥æ‰§è¡Œï¼Œä¸é˜»å¡é¡µé¢
      if (needsInitialization && !initializationRef.current.isRecovering) {
        console.log('[VideosPage] ğŸ”„ å¯åŠ¨åå°ä»»åŠ¡æ¢å¤æµç¨‹...')
        
        // æ›´æ–°å½“å‰ç”¨æˆ·ID
        initializationRef.current.currentUserId = user.id
        
        // æ¢å¤å¤„ç†ä¸­çš„ä»»åŠ¡
        const recoverTasks = async () => {
          if (initializationRef.current.isRecovering) {
            console.log('[VideosPage] ä»»åŠ¡æ¢å¤å·²åœ¨è¿›è¡Œä¸­ï¼Œè·³è¿‡...')
            return
          }
          
          initializationRef.current.isRecovering = true
          setTaskRecovery(prev => ({ ...prev, isRecovering: true }))
          
          try {
            console.log('[VideosPage] å¼€å§‹ä»»åŠ¡æ¢å¤...')
            const result = await taskRecoveryService.recoverProcessingTasks(user.id)
          
          console.log('[VideosPage] ä»»åŠ¡æ¢å¤å®Œæˆ:', result)
          setTaskRecovery({
            isRecovering: false,
            restoredCount: result.restoredCount,
            resumedCount: result.resumedPollingCount
          })
          
          // æ¸…ç†å¡ä½çš„ä»»åŠ¡
          console.log('[VideosPage] å¼€å§‹æ¸…ç†å¡ä½çš„ä»»åŠ¡...')
          const cleanedCount = await taskRecoveryService.cleanupStuckTasks(user.id)
          if (cleanedCount > 0) {
            console.log(`[VideosPage] æ¸…ç†äº† ${cleanedCount} ä¸ªå¡ä½çš„ä»»åŠ¡`)
          }
          
          // æ¢å¤åé‡æ–°åŠ è½½è§†é¢‘åˆ—è¡¨ä»¥è·å–æœ€æ–°çŠ¶æ€
          if (result.restoredCount > 0 || result.resumedPollingCount > 0 || cleanedCount > 0) {
            loadVideos()
            
            // æ¢å¤çš„è§†é¢‘ç›‘å¬å™¨å°†ç”± useEffect ä¸­çš„ activeSubscriptions è‡ªåŠ¨ç®¡ç†
            if (result.restoredVideoIds && result.restoredVideoIds.length > 0) {
              console.log('[VideosPage] æ¢å¤çš„è§†é¢‘ç›‘å¬å™¨å°†åœ¨ä¸‹æ¬¡è§†é¢‘åˆ—è¡¨æ›´æ–°æ—¶è‡ªåŠ¨åˆ›å»º:', result.restoredVideoIds)
            }
          }
          
          // 3ç§’åéšè—æ¢å¤çŠ¶æ€æŒ‡ç¤ºå™¨
          setTimeout(() => {
            setTaskRecovery(prev => ({ 
              ...prev, 
              restoredCount: 0, 
              resumedCount: 0 
            }))
          }, 3000)
          
          } catch (error) {
            console.error('[VideosPage] ä»»åŠ¡æ¢å¤å¤±è´¥:', error)
            setTaskRecovery(prev => ({ ...prev, isRecovering: false }))
          } finally {
            initializationRef.current.isRecovering = false
          }
        }
        
        // åˆå§‹åŒ–ä»»åŠ¡ç®¡ç†å™¨
        const initTaskManager = async () => {
          if (initializationRef.current.isTaskManagerInitialized) {
            console.log('[VideosPage] ä»»åŠ¡ç®¡ç†å™¨å·²åˆå§‹åŒ–ï¼Œè·³è¿‡...')
            return
          }
          
          try {
            console.log('[VideosPage] åˆå§‹åŒ–ä»»åŠ¡ç®¡ç†å™¨...')
            const activeTasks = await videoTaskManager.initialize(user.id)
            console.log(`[VideosPage] ä»»åŠ¡ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆï¼Œå‘ç° ${activeTasks.length} ä¸ªæ´»è·ƒä»»åŠ¡`)
            
            initializationRef.current.isTaskManagerInitialized = true
          
          // æ‰§è¡ŒçŠ¶æ€ä¸€è‡´æ€§æ£€æŸ¥
          console.log('[VideosPage] ğŸ” æ‰§è¡ŒçŠ¶æ€ä¸€è‡´æ€§æ£€æŸ¥...')
          const consistencyResult = await progressManager.validateStateConsistency(user.id)
          if (consistencyResult.fixed > 0) {
            console.log(`[VideosPage] ğŸ”§ çŠ¶æ€ä¸€è‡´æ€§æ£€æŸ¥ä¿®å¤äº† ${consistencyResult.fixed} ä¸ªä¸ä¸€è‡´`)
            // å¦‚æœæœ‰ä¿®å¤ï¼Œé‡æ–°åŠ è½½è§†é¢‘åˆ—è¡¨
            loadVideos()
          }
          
          // å¯åŠ¨è½®è¯¢æœåŠ¡ï¼ŒæŒç»­ç›‘æ§ä»»åŠ¡çŠ¶æ€ï¼ˆå³ä½¿å½“å‰æ²¡æœ‰æ´»è·ƒä»»åŠ¡ä¹Ÿè¦å¯åŠ¨ï¼Œä»¥ä¾¿ç›‘æ§æ–°ä»»åŠ¡ï¼‰
          console.log('[VideosPage] å¯åŠ¨è½®è¯¢æœåŠ¡ç›‘æ§ä»»åŠ¡çŠ¶æ€')
          videoPollingService.start({
              userId: user.id,
              onTaskUpdate: (task: VideoTask) => {
                console.log(`[VideosPage] ä»»åŠ¡çŠ¶æ€æ›´æ–°: ${task.id} -> ${task.status} (${task.progress}%)`)
                
                // æ›´æ–°è¿›åº¦æ˜¾ç¤º
                if (task.status === 'processing' || task.status === 'pending') {
                  progressManager.updateProgress(task.id, {
                    progress: task.progress,
                    status: task.status,
                    statusText: task.statusText,
                    qingyunTaskId: task.veo3JobId
                  })
                }
              },
              onTaskComplete: (task: VideoTask) => {
                console.log(`[VideosPage] âœ… ä»»åŠ¡å®Œæˆ: ${task.id}`)
                
                // æ ‡è®°è¿›åº¦å®Œæˆ
                if (task.videoUrl) {
                  progressManager.markAsCompleted(task.id, task.videoUrl)
                }
                
                // é‡æ–°åŠ è½½è§†é¢‘åˆ—è¡¨ä»¥æ˜¾ç¤ºæœ€æ–°çŠ¶æ€
                loadVideos()
                loadStatistics()
              },
              onTaskFailed: (task: VideoTask) => {
                console.log(`[VideosPage] âŒ ä»»åŠ¡å¤±è´¥: ${task.id}`)
                
                // æ ‡è®°è¿›åº¦å¤±è´¥
                progressManager.markAsFailed(task.id, task.errorMessage || 'ä»»åŠ¡å¤„ç†å¤±è´¥')
                
                // é‡æ–°åŠ è½½è§†é¢‘åˆ—è¡¨
                loadVideos()
                loadStatistics()
              }
            })
            
            // å¯åŠ¨çŠ¶æ€åŒæ­¥æ£€æŸ¥å®šæ—¶å™¨
            console.log('[VideosPage] ğŸ”„ å¯åŠ¨çŠ¶æ€åŒæ­¥æ£€æŸ¥å®šæ—¶å™¨')
            const stopSyncTimer = progressManager.startStateSyncTimer(user.id)
            
            // å°†æ¸…ç†å‡½æ•°ä¿å­˜åˆ°refä¸­ï¼Œä»¥ä¾¿åœ¨ç»„ä»¶å¸è½½æ—¶è°ƒç”¨
            if (!initializationRef.current.currentUserId) {
              initializationRef.current = {
                ...initializationRef.current,
                stopSyncTimer
              } as any
            }
          } catch (error) {
            console.error('[VideosPage] ä»»åŠ¡ç®¡ç†å™¨åˆå§‹åŒ–å¤±è´¥:', error)
            initializationRef.current.isTaskManagerInitialized = false
          }
        }

        // ğŸš€ å…³é”®ä¼˜åŒ–ï¼šåå°å¼‚æ­¥æ‰§è¡Œä»»åŠ¡æ¢å¤ï¼Œä¸é˜»å¡é¡µé¢æ˜¾ç¤º
        const backgroundInitStart = performance.now()
        console.log('[VideosPage] ğŸ”„ å¼€å§‹åå°ä»»åŠ¡æ¢å¤å’Œç®¡ç†å™¨åˆå§‹åŒ–...')
        
        // åå°å¼‚æ­¥æ‰§è¡Œæ¢å¤æµç¨‹ï¼ˆä¿æŒé€»è¾‘ä¾èµ–å…³ç³»ï¼‰
        setTimeout(() => {
          console.log(`[PERF] ğŸ”„ ========== åå°ä»»åŠ¡æ¢å¤å¼€å§‹ ==========`)
          console.log(`[PERF] â° åå°æµç¨‹å¼€å§‹æ—¶é—´: ${Math.round(performance.now() - performanceTimers.current.componentMount)}ms`)
          
          const recoveryStart = performance.now()
          recoverTasks()
            .then((recoveryResult) => {
              const recoveryTime = performance.now() - recoveryStart
              performanceTimers.current.taskRecoveryComplete = performance.now()
              
              console.log(`[PERF] âœ… ä»»åŠ¡æ¢å¤é˜¶æ®µå®Œæˆ: ${Math.round(recoveryTime)}ms`)
              console.log(`[PERF] ğŸ“Š æ¢å¤ç»Ÿè®¡: è¿›åº¦${(recoveryResult as any)?.restoredCount || 0}ä¸ª, è½®è¯¢${(recoveryResult as any)?.resumedPollingCount || 0}ä¸ª`)
              
              // æ¢å¤å®Œæˆåå†åˆå§‹åŒ–ä»»åŠ¡ç®¡ç†å™¨
              const taskManagerStart = performance.now()
              console.log(`[PERF] ğŸ”§ å¼€å§‹ä»»åŠ¡ç®¡ç†å™¨åˆå§‹åŒ–...`)
              return initTaskManager().then(() => {
                const taskManagerTime = performance.now() - taskManagerStart
                console.log(`[PERF] âœ… ä»»åŠ¡ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ: ${Math.round(taskManagerTime)}ms`)
              })
            })
            .then(() => {
              const backgroundInitTime = performance.now() - backgroundInitStart
              const totalTimeFromMount = performance.now() - performanceTimers.current.componentMount
              
              console.log(`[PERF] ğŸ‰ ========== å®Œæ•´åå°åˆå§‹åŒ–å®Œæˆ ==========`)
              console.log(`[PERF] â±ï¸  åå°æµç¨‹æ€»è€—æ—¶: ${Math.round(backgroundInitTime)}ms`)
              console.log(`[PERF] ğŸ• ä»æŒ‚è½½åˆ°å®Œå…¨åˆå§‹åŒ–: ${Math.round(totalTimeFromMount)}ms`)
              console.log(`[PERF] ğŸ“ˆ æ€§èƒ½åˆ†è§£:`)
              console.log(`[PERF]   - é¦–æ¬¡æ¸²æŸ“: ${Math.round(performanceTimers.current.firstRender - performanceTimers.current.componentMount)}ms`)
              console.log(`[PERF]   - æ•°æ®åŠ è½½: ${Math.round(performanceTimers.current.dataLoaded - performanceTimers.current.componentMount)}ms`) 
              console.log(`[PERF]   - ä»»åŠ¡æ¢å¤: ${Math.round(performanceTimers.current.taskRecoveryComplete - performanceTimers.current.componentMount)}ms`)
              console.log(`[PERF] =======================================`)
            })
            .catch(error => {
              const backgroundInitTime = performance.now() - backgroundInitStart
              console.error(`[PERF] âŒ åå°åˆå§‹åŒ–å¤±è´¥: ${Math.round(backgroundInitTime)}ms`, error)
            })
        }, 0) // ä½¿ç”¨ setTimeout 0 è®©å®ƒåœ¨ä¸‹ä¸ªäº‹ä»¶å¾ªç¯æ‰§è¡Œï¼Œä¸é˜»å¡å½“å‰æ¸²æŸ“
      } else {
        console.log('[VideosPage] è·³è¿‡åˆå§‹åŒ–ï¼Œå½“å‰çŠ¶æ€:', {
          needsInitialization,
          isRecovering: initializationRef.current.isRecovering
        })
      }
      
      // è®¢é˜…ç”¨æˆ·è§†é¢‘åˆ›å»º
      const unsubscribeNewVideos = supabaseVideoService.subscribeToUserVideos(
        user.id,
        (newVideo) => {
          console.log('[VideosPage] New video created:', newVideo)
          // æ·»åŠ åˆ°è§†é¢‘åˆ—è¡¨é¡¶éƒ¨
          setVideos(prev => [newVideo, ...prev])
          loadStatistics() // é‡æ–°åŠ è½½ç»Ÿè®¡
        }
      )
      
      // è®¢é˜…ç”¨æˆ·è§†é¢‘æ›´æ–°ï¼ˆç›‘å¬çŠ¶æ€å˜åŒ–ï¼‰
      const unsubscribeUpdates = supabaseVideoService.subscribeToAllUserVideoUpdates(
        user.id,
        (updatedVideo) => {
          console.log('[VideosPage] Video updated via global subscription:', updatedVideo.id, updatedVideo.status)
          
          // æ›´æ–°è§†é¢‘åˆ—è¡¨ä¸­çš„å¯¹åº”è®°å½•
          setVideos(prev => prev.map(v => 
            v.id === updatedVideo.id ? updatedVideo : v
          ))
          
          // å¦‚æœè§†é¢‘å®Œæˆï¼Œæ¸…ç†è¿›åº¦æ•°æ®å¹¶æ˜¾ç¤ºé€šçŸ¥ï¼ˆå¦‚æœæ˜¯é«˜äº®è§†é¢‘ï¼‰
          if (updatedVideo.status === 'completed') {
            // ç«‹å³æ¸…ç†è¿›åº¦æ•°æ®
            setVideoProgress(prev => {
              const newMap = new Map(prev)
              newMap.delete(updatedVideo.id)
              return newMap
            })
            console.log(`[VideosPage] Video completed, cleared progress data: ${updatedVideo.id}`)
            
            // å¼ºåˆ¶UIé‡æ–°æ¸²æŸ“ï¼Œç¡®ä¿æ˜¾ç¤ºè§†é¢‘é¢„è§ˆ
            setTimeout(() => {
              setVideos(prev => prev.map(v => 
                v.id === updatedVideo.id ? { ...updatedVideo } : v
              ))
            }, 100)
          }
          
          loadStatistics() // é‡æ–°åŠ è½½ç»Ÿè®¡
        }
      )
      
      // å¹¿æ’­ç›‘å¬å™¨ç”± useEffect ä¸­çš„ activeSubscriptions ç®¡ç†ï¼Œè¿™é‡Œä¸éœ€è¦é‡å¤åˆ›å»º
      
      // æ¸…ç†ä¸éœ€è¦çš„å¹¿æ’­é¢‘é“ï¼ˆä¸åœ¨å½“å‰é¡µé¢çš„è§†é¢‘ï¼‰
      const currentVideoIds = videos.map(v => v.id)
      setBroadcastChannels(prev => {
        const cleanedMap = new Map()
        const currentVideoIdSet = new Set(currentVideoIds)
        
        prev.forEach((channel, videoId) => {
          if (currentVideoIdSet.has(videoId)) {
            // ä¿ç•™å½“å‰é¡µé¢çš„è§†é¢‘é¢‘é“
            cleanedMap.set(videoId, channel)
          } else {
            // æ¸…ç†ä¸éœ€è¦çš„é¢‘é“
            channel.unsubscribe()
            console.log(`[VideosPage] ğŸ“¡ Cleaned up unused channel: ${videoId}`)
          }
        })
        
        return cleanedMap
      })
      
      return () => {
        console.log('[VideosPage] å¼€å§‹æ¸…ç†...', { 
          userId: user?.id, 
          isTaskManagerInitialized: initializationRef.current.isTaskManagerInitialized 
        })
        
        unsubscribeNewVideos()
        unsubscribeUpdates()
        
        // åªæœ‰å·²åˆå§‹åŒ–çš„æœåŠ¡æ‰éœ€è¦åœæ­¢
        if (initializationRef.current.isTaskManagerInitialized) {
          // åœæ­¢è½®è¯¢æœåŠ¡
          console.log('[VideosPage] åœæ­¢è½®è¯¢æœåŠ¡')
          videoPollingService.stop()
          
          // æ¸…ç†ä»»åŠ¡ç®¡ç†å™¨
          console.log('[VideosPage] æ¸…ç†ä»»åŠ¡ç®¡ç†å™¨')
          videoTaskManager.cleanup()
          
          // åœæ­¢çŠ¶æ€åŒæ­¥å®šæ—¶å™¨
          if ((initializationRef.current as any).stopSyncTimer) {
            console.log('[VideosPage] ğŸ”’ åœæ­¢çŠ¶æ€åŒæ­¥å®šæ—¶å™¨')
            ;(initializationRef.current as any).stopSyncTimer()
          }
          
          // é‡ç½®åˆå§‹åŒ–çŠ¶æ€
          initializationRef.current.isTaskManagerInitialized = false
        }
        
        // é‡ç½®æ¢å¤çŠ¶æ€
        initializationRef.current.isRecovering = false
        
        // æ¸…ç†å¹¿æ’­é¢‘é“
        broadcastChannels.forEach((channel, videoId) => {
          channel.unsubscribe()
          console.log(`[VideosPage] ğŸ“¡ Unsubscribed from channel: ${videoId}`)
        })
        setBroadcastChannels(new Map()) // æ¸…ç©ºå¹¿æ’­é¢‘é“Map
        console.log('[VideosPage] ğŸ“¡ æ¸…ç†å®Œæˆ')
      }
    }
  }, [user, uiState.page])


  // useEffect(() => {
  //   // ğŸš€ æ€§èƒ½ç›‘æ§ï¼šè¿‡æ»¤æ“ä½œæ€§èƒ½è¿½è¸ª
  //   console.log(`[PERF] ğŸ” è§¦å‘è§†é¢‘è¿‡æ»¤ï¼Œå½“å‰è§†é¢‘æ•°: ${videos.length}`)
  //   const filterStart = performance.now()
  //   
  //   applyFilters()
  //   
  //   const filterTime = performance.now() - filterStart
  //   console.log(`[PERF] âœ… è§†é¢‘è¿‡æ»¤è§¦å‘å®Œæˆ: ${Math.round(filterTime)}ms`)
  // }, [videos, uiState.filter, uiState.searchTerm, applyFilters]) // ä¿®å¤ä¾èµ–é¡¹
  
  // è®¢é˜…æ•°æ®åº“çŠ¶æ€æ›´æ–°å’Œå†…å­˜è¿›åº¦æ›´æ–°
  const activeSubscriptions = React.useRef<Map<string, () => void>>(new Map())
  const progressSubscriptions = React.useRef<Map<string, () => void>>(new Map())
  
  // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨ useMemo ç¼“å­˜è®¢é˜…ä¾èµ–é¡¹ï¼Œé¿å…ä¸å¿…è¦çš„é‡æ–°è®¢é˜…
  const videosSubscriptionKey = React.useMemo(() => {
    // åªå…³æ³¨éœ€è¦è®¢é˜…çš„è§†é¢‘ï¼ˆå¤„ç†ä¸­ã€ç­‰å¾…ä¸­ã€æœ€è¿‘å®Œæˆçš„ï¼‰
    const relevantVideos = videos.filter(video => {
      const recentlyCompleted = video.status === 'completed' && 
        video.processing_completed_at && 
        (new Date().getTime() - new Date(video.processing_completed_at).getTime()) < 5 * 60 * 1000
      
      return video.status === 'processing' || video.status === 'pending' || recentlyCompleted
    })
    
    return relevantVideos.map(v => `${v.id}-${v.status}`).join(',')
  }, [videos])
  
  useEffect(() => {
    if (!user) return
    
    // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šåªå¤„ç†éœ€è¦è®¢é˜…çš„è§†é¢‘ï¼Œå‡å°‘å¾ªç¯å¼€é”€
    const subscriptionStart = performance.now()
    console.log('[VideosPage] ğŸ”„ ä¼˜åŒ–åçš„è®¢é˜…ç®¡ç†å¼€å§‹...')
    console.log(`[PERF] ğŸ“¡ å¼€å§‹åˆ›å»ºè®¢é˜…ï¼Œå½“å‰è§†é¢‘æ•°: ${videos.length}`)
    
    // æ¸…ç†å·²ç»ä¸éœ€è¦çš„æ•°æ®åº“è®¢é˜…
    const currentVideoIds = new Set(videos.map(v => v.id))
    for (const [videoId, unsubscribe] of activeSubscriptions.current.entries()) {
      if (!currentVideoIds.has(videoId)) {
        unsubscribe()
        activeSubscriptions.current.delete(videoId)
      }
    }
    
    // æ¸…ç†å·²ç»ä¸éœ€è¦çš„è¿›åº¦è®¢é˜…
    for (const [videoId, unsubscribe] of progressSubscriptions.current.entries()) {
      if (!currentVideoIds.has(videoId)) {
        unsubscribe()
        progressSubscriptions.current.delete(videoId)
      }
    }
    
    // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šåªä¸ºçœŸæ­£éœ€è¦ç›‘æ§çš„è§†é¢‘åˆ›å»ºè®¢é˜…
    const relevantVideos = videos.filter(video => {
      const recentlyCompleted = video.status === 'completed' && 
        video.processing_completed_at && 
        (new Date().getTime() - new Date(video.processing_completed_at).getTime()) < 5 * 60 * 1000 // 5åˆ†é’Ÿå†…
      
      return video.status === 'processing' || 
             video.status === 'pending' || 
             recentlyCompleted
    })
    
    console.log(`[VideosPage] ğŸ“Š éœ€è¦è®¢é˜…çš„è§†é¢‘æ•°é‡: ${relevantVideos.length} / ${videos.length}`)
    
    relevantVideos.forEach(video => {
      const shouldSubscribe = !activeSubscriptions.current.has(video.id)
      
      if (shouldSubscribe) {
        
        const unsubscribe = supabaseVideoService.subscribeToVideoUpdates(
          video.id,
          (updatedVideo) => {
            console.log('[VideosPage] Video status updated:', updatedVideo.status)
            
            // æ›´æ–°è§†é¢‘åˆ—è¡¨ä¸­çš„å¯¹åº”è®°å½•
            setVideos(prev => prev.map(v => 
              v.id === updatedVideo.id ? updatedVideo : v
            ))
            
            // å¦‚æœè§†é¢‘å®Œæˆï¼Œæ¸…ç†è¿›åº¦æ•°æ®ã€æ˜¾ç¤ºé€šçŸ¥å¹¶æ¸…ç†è®¢é˜…
            if (updatedVideo.status === 'completed') {
              // ç«‹å³æ¸…ç†è¿›åº¦æ•°æ®
              setVideoProgress(prev => {
                const newMap = new Map(prev)
                newMap.delete(updatedVideo.id)
                return newMap
              })
              console.log(`[VideosPage] Video completed via individual subscription, cleared progress data: ${updatedVideo.id}`)
              
              // å¼ºåˆ¶UIé‡æ–°æ¸²æŸ“ï¼Œç¡®ä¿æ˜¾ç¤ºè§†é¢‘é¢„è§ˆ
              setTimeout(() => {
                setVideos(prev => prev.map(v => 
                  v.id === updatedVideo.id ? { ...updatedVideo } : v
                ))
              }, 100)
              
              showCompletionNotification(updatedVideo)
              const unsub = activeSubscriptions.current.get(video.id)
              if (unsub) {
                unsub()
                activeSubscriptions.current.delete(video.id)
              }
            }
            
            loadStatistics()
          }
        )
        
        activeSubscriptions.current.set(video.id, unsubscribe)
        console.log(`[VideosPage] Subscribed to video status updates: ${video.id}`)
      }
      
      // è¿›åº¦è®¢é˜…ï¼ˆè®¢é˜…å¤„ç†ä¸­æˆ–ç­‰å¾…ä¸­çš„è§†é¢‘ï¼‰
      const shouldSubscribeProgress = (
        video.status === 'processing' || 
        video.status === 'pending'
      ) && !progressSubscriptions.current.has(video.id)
      
      if (shouldSubscribeProgress) {
        
        // é¦–å…ˆå°è¯•ä» progressManager è·å–å¸¦ fallback çš„è¿›åº¦æ•°æ®
        progressManager.getProgressWithFallback(video.id, video.status).then(initialProgress => {
          if (initialProgress) {
            setVideoProgress(prev => {
              const newMap = new Map(prev)
              newMap.set(video.id, initialProgress)
              return newMap
            })
            console.log(`[VideosPage] Initialized progress for ${video.id}: ${initialProgress.progress}%`)
          }
        }).catch(error => {
          console.error(`[VideosPage] Failed to get initial progress for ${video.id}:`, error)
        })
        
        const unsubscribeProgress = progressManager.subscribe(
          video.id,
          (progress) => {
            console.log(`[VideosPage] Progress updated for ${video.id}: ${progress.progress}%`)
            
            setVideoProgress(prev => {
              const newMap = new Map(prev)
              newMap.set(video.id, progress)
              return newMap
            })
          }
        )
        
        progressSubscriptions.current.set(video.id, unsubscribeProgress)
        console.log(`[VideosPage] Subscribed to progress updates: ${video.id}`)
      }
    })
    
    // ç»„ä»¶å¸è½½æ—¶æ¸…ç†æ‰€æœ‰è®¢é˜…
    return () => {
      for (const unsubscribe of activeSubscriptions.current.values()) {
        unsubscribe()
      }
      activeSubscriptions.current.clear()
      
      for (const unsubscribe of progressSubscriptions.current.values()) {
        unsubscribe()
      }
      progressSubscriptions.current.clear()
    }
    
    // ğŸš€ æ€§èƒ½ç›‘æ§ï¼šè®¢é˜…åˆ›å»ºå®Œæˆæ—¶é—´ç»Ÿè®¡
    const subscriptionTime = performance.now() - subscriptionStart
    const totalFromMount = performance.now() - performanceTimers.current.componentMount
    console.log(`[PERF] âœ… è®¢é˜…ç®¡ç†å®Œæˆ: ${Math.round(subscriptionTime)}ms`)
    console.log(`[PERF] ğŸ“Š æ´»è·ƒè®¢é˜…: DBè®¢é˜… ${activeSubscriptions.current.size} ä¸ª, è¿›åº¦è®¢é˜… ${progressSubscriptions.current.size} ä¸ª`)
    console.log(`[PERF] ğŸ• ä»æŒ‚è½½åˆ°è®¢é˜…å®Œæˆ: ${Math.round(totalFromMount)}ms`)
    
  }, [user, videosSubscriptionKey]) // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨ç¼“å­˜çš„ä¾èµ–é¡¹ï¼Œé¿å…é‡å¤è®¡ç®—

  // æ˜¾ç¤ºå®Œæˆé€šçŸ¥
  const showCompletionNotification = async (video: Video) => {
    // é˜²æ­¢é‡å¤é€šçŸ¥
    if (notifiedVideos.has(video.id)) {
      console.log(`[VideosPage] Completion notification already shown for video: ${video.id}`)
      return
    }
    
    console.log(`[VideosPage] Showing completion notification for video: ${video.id}`)
    
    // æ ‡è®°å·²é€šçŸ¥ï¼Œé˜²æ­¢é‡å¤
    setNotifiedVideos(prev => new Set(prev).add(video.id))
    
    // 1. å…ˆä»æ•°æ®åº“è·å–æœ€æ–°çš„è§†é¢‘æ•°æ®ï¼Œç¡®ä¿æœ‰æœ€æ–°çš„çŠ¶æ€
    try {
      const latestVideo = await supabaseVideoService.getVideo(video.id)
      if (latestVideo) {
        // 2. æ›´æ–°videosçŠ¶æ€ä¸­çš„å¯¹åº”è®°å½•ï¼Œç¡®ä¿ä½¿ç”¨æœ€æ–°æ•°æ®
        setVideos(prev => prev.map(v => 
          v.id === latestVideo.id ? latestVideo : v
        ))
        console.log(`[VideosPage] Updated video state with latest data: ${latestVideo.id}, status: ${latestVideo.status}`)
        
        // 3. ä½¿ç”¨æœ€æ–°æ•°æ®æ˜¾ç¤ºé€šçŸ¥
        setCompletionNotification({ visible: true, video: latestVideo })
      } else {
        // å¦‚æœè·å–ä¸åˆ°æœ€æ–°æ•°æ®ï¼Œä½¿ç”¨ä¼ å…¥çš„æ•°æ®
        setCompletionNotification({ visible: true, video })
      }
    } catch (error) {
      console.warn('[VideosPage] Failed to fetch latest video data, using provided data:', error)
      setCompletionNotification({ visible: true, video })
    }
    
    // 4. ç«‹å³æ¸…ç†è¿›åº¦æ•°æ®ï¼Œç¡®ä¿ä¸å†æ˜¾ç¤ºè¿›åº¦æ¡
    setVideoProgress(prev => {
      const newMap = new Map(prev)
      newMap.delete(video.id)
      return newMap
    })
    console.log(`[VideosPage] Cleared progress data for completed video: ${video.id}`)
    
    // 5. ä¸è¦åœ¨è¿™é‡Œæ¸…ç†progressManagerä¸­çš„æ•°æ®ï¼Œè®©å®ƒè‡ªç„¶å»¶è¿Ÿæ¸…ç†
    // progressManager.clearProgress(video.id)
    
    // æ’­æ”¾é€šçŸ¥éŸ³ï¼ˆå¦‚æœæµè§ˆå™¨å…è®¸ï¼‰
    try {
      const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBjiAw+/VeSsFJHbD7+6qVRMJSJns8qJbCApGjt7yu2k=')
      audio.volume = 0.3
      audio.play().catch(() => {}) // å¿½ç•¥è‡ªåŠ¨æ’­æ”¾é™åˆ¶
    } catch (e) {
      // å¿½ç•¥éŸ³é¢‘æ’­æ”¾é”™è¯¯
    }
    
    // 5ç§’åè‡ªåŠ¨éšè—é€šçŸ¥
    setTimeout(() => {
      setCompletionNotification({ visible: false, video: null })
      
    }, 5000) // å»¶é•¿é€šçŸ¥æ˜¾ç¤ºæ—¶é—´åˆ°5ç§’
  }

  const loadVideos = React.useCallback(async () => {
    if (!user) return
    
    // ğŸš€ æ€§èƒ½ç›‘æ§ï¼šæ•°æ®åŠ è½½è®¡æ—¶å¼€å§‹
    const loadStart = performance.now()
    console.log(`[PERF] ğŸ“¡ å¼€å§‹åŠ è½½è§†é¢‘æ•°æ®...`)
    console.log(`[PERF] ğŸ“‹ æŸ¥è¯¢å‚æ•°: çŠ¶æ€=${uiState.filter.status || 'all'}, æœç´¢=${uiState.searchTerm || 'none'}, é¡µç =${uiState.page}`)
    
    setUiState(prev => ({ ...prev, loading: true }))
    try {
      const { videos: fetchedVideos, total, pageSize } = await supabaseVideoService.getUserVideos(
        user.id,
        {
          status: uiState.filter.status,
          searchTerm: uiState.searchTerm || undefined
        },
        {
          page: uiState.page,
          pageSize: 12,
          sortBy: 'created_at',
          sortOrder: 'desc'
        }
      )
      
      const loadTime = performance.now() - loadStart
      performanceTimers.current.dataLoaded = performance.now()
      
      console.log(`[PERF] âœ… è§†é¢‘æ•°æ®åŠ è½½å®Œæˆ: ${Math.round(loadTime)}ms`)
      console.log(`[PERF] ğŸ“Š åŠ è½½ç»“æœ: ${fetchedVideos.length} ä¸ªè§†é¢‘, æ€»è®¡ ${total} ä¸ª`)
      console.log(`[PERF] ğŸ“ˆ ç´¯è®¡æ—¶é—´: ${Math.round(performanceTimers.current.dataLoaded - performanceTimers.current.componentMount)}ms`)
      
      setVideos(fetchedVideos)
      setUiState(prev => ({ ...prev, totalPages: Math.ceil(total / pageSize) }))
      
      // è®°å½•é¡µé¢å®Œå…¨å¯äº¤äº’çš„æ—¶é—´ç‚¹
      if (performanceTimers.current.fullyInteractive === 0) {
        performanceTimers.current.fullyInteractive = performance.now()
        const totalInteractiveTime = performanceTimers.current.fullyInteractive - performanceTimers.current.componentMount
        console.log(`[PERF] ğŸ¯ é¡µé¢å®Œå…¨å¯äº¤äº’: ${Math.round(totalInteractiveTime)}ms`)
      }
      
    } catch (error) {
      const loadTime = performance.now() - loadStart
      console.error(`[PERF] âŒ è§†é¢‘æ•°æ®åŠ è½½å¤±è´¥: ${Math.round(loadTime)}ms`, error)
    } finally {
      setUiState(prev => ({ ...prev, loading: false }))
    }
  }, [user, uiState.filter.status, uiState.searchTerm, uiState.page]) // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šç¼“å­˜å‡½æ•°ï¼Œç²¾ç¡®ä¾èµ–

  const loadStatistics = React.useCallback(async () => {
    if (!user) return
    
    // ğŸš€ æ€§èƒ½ç›‘æ§ï¼šç»Ÿè®¡æ•°æ®åŠ è½½è®¡æ—¶
    const statsStart = performance.now()
    console.log(`[PERF] ğŸ“Š å¼€å§‹åŠ è½½ç»Ÿè®¡æ•°æ®...`)
    
    try {
      const stats = await supabaseVideoService.getUserStatistics(user.id)
      const statsTime = performance.now() - statsStart
      console.log(`[PERF] âœ… ç»Ÿè®¡æ•°æ®åŠ è½½å®Œæˆ: ${Math.round(statsTime)}ms`)
      console.log(`[PERF] ğŸ“ˆ ç»Ÿè®¡ç»“æœ:`, stats)
      
      setStatistics(stats)
    } catch (error) {
      const statsTime = performance.now() - statsStart
      console.error(`[PERF] âŒ ç»Ÿè®¡æ•°æ®åŠ è½½å¤±è´¥: ${Math.round(statsTime)}ms`, error)
    }
  }, [user]) // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šç¼“å­˜ç»Ÿè®¡åŠ è½½å‡½æ•°

  // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨ useMemo ç¼“å­˜è¿‡æ»¤ç»“æœï¼Œé¿å…é‡å¤è®¡ç®—
  React.useEffect(() => {
    // ğŸš€ æ€§èƒ½ç›‘æ§ï¼šè¿‡æ»¤è®¡ç®—è®¡æ—¶
    const filterStart = performance.now()
    console.log(`[PERF] ğŸ” å¼€å§‹è¿‡æ»¤è§†é¢‘åˆ—è¡¨ï¼ŒåŸå§‹æ•°é‡: ${videos.length}`)
    
    let filtered = [...videos]

    // Apply status filter (already applied in loadVideos, but kept for local filtering)
    if (uiState.filter.status) {
      filtered = filtered.filter(v => v.status === uiState.filter.status)
    }

    // Apply search (already applied in loadVideos, but kept for local filtering)
    if (uiState.searchTerm) {
      const term = uiState.searchTerm.toLowerCase()
      filtered = filtered.filter(v => 
        (v.title?.toLowerCase().includes(term) || false) ||
        (v.prompt?.toLowerCase().includes(term) || false)
      )
    }

    const filterTime = performance.now() - filterStart
    console.log(`[PERF] âœ… è§†é¢‘è¿‡æ»¤å®Œæˆ: ${Math.round(filterTime)}ms, ç»“æœæ•°é‡: ${filtered.length}`)
    
    setFilteredVideos(filtered)
    
    // ğŸš€ æ€§èƒ½ç›‘æ§ï¼šè¾“å‡ºå®Œæ•´æ€§èƒ½æŠ¥å‘Šï¼ˆå»¶è¿Ÿæ‰§è¡Œç¡®ä¿çŠ¶æ€æ›´æ–°å®Œæˆï¼‰
    setTimeout(() => {
      const now = performance.now()
      const totalTime = now - performanceTimers.current.componentMount
      
      console.log(`[PERF] ğŸ“Š ========== VideosPage æ€§èƒ½æŠ¥å‘Š ==========`)
      console.log(`[PERF] ğŸ• æ€»è€—æ—¶: ${Math.round(totalTime)}ms`)
      console.log(`[PERF] ğŸ“ˆ å…³é”®èŠ‚ç‚¹æ—¶é—´:`)
      console.log(`[PERF]   â”œâ”€ é¦–æ¬¡æ¸²æŸ“: ${Math.round(performanceTimers.current.firstRender - performanceTimers.current.componentMount)}ms`)
      if (performanceTimers.current.dataLoaded > 0) {
        console.log(`[PERF]   â”œâ”€ æ•°æ®åŠ è½½: ${Math.round(performanceTimers.current.dataLoaded - performanceTimers.current.componentMount)}ms`)
      }
      if (performanceTimers.current.fullyInteractive > 0) {
        console.log(`[PERF]   â”œâ”€ å®Œå…¨å¯äº¤äº’: ${Math.round(performanceTimers.current.fullyInteractive - performanceTimers.current.componentMount)}ms`)
      }
      if (performanceTimers.current.taskRecoveryComplete > 0) {
        console.log(`[PERF]   â””â”€ ä»»åŠ¡æ¢å¤å®Œæˆ: ${Math.round(performanceTimers.current.taskRecoveryComplete - performanceTimers.current.componentMount)}ms`)
      }
      console.log(`[PERF] ğŸ“Š å½“å‰çŠ¶æ€: ${videos.length} è§†é¢‘, ${filtered.length} å·²è¿‡æ»¤`)
      console.log(`[PERF] =========================================`)
    }, 50) // å»¶è¿Ÿ50msç¡®ä¿æ‰€æœ‰çŠ¶æ€æ›´æ–°å®Œæˆ
  }, [videos, uiState.filter.status, uiState.searchTerm]) // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šç²¾ç¡®ä¾èµ–ï¼Œè‡ªåŠ¨åº”ç”¨è¿‡æ»¤


  const handleDownloadVideo = React.useCallback(async (video: Video) => {
    console.log('[VideosPage] handleDownloadVideo è¢«è°ƒç”¨:', {
      videoId: video.id,
      videoUrl: video.video_url,
      title: video.title,
      status: video.status
    })
    
    if (!video.video_url) {
      console.warn('[VideosPage] è§†é¢‘URLä¸ºç©ºï¼Œæ— æ³•ä¸‹è½½')
      toast.error('è§†é¢‘URLä¸å­˜åœ¨ï¼Œæ— æ³•ä¸‹è½½')
      return
    }
    
    // æ˜¾ç¤ºå¼€å§‹ä¸‹è½½çš„æç¤º
    toast.info('æ­£åœ¨å¯åŠ¨ä¸‹è½½ï¼Œå¦‚æœæ²¡æœ‰è‡ªåŠ¨ä¸‹è½½ï¼Œè¯·åœ¨æ–°çª—å£ä¸­å³é”®ä¿å­˜è§†é¢‘', { 
      id: 'download-' + video.id,
      duration: 3000
    })
    
    try {
      const filename = `${video.title || 'video'}-${video.id}.mp4`
      console.log('[VideosPage] å‡†å¤‡ä¸‹è½½ï¼Œæ–‡ä»¶å:', filename)
      
      await videoShareService.downloadVideo(video.id, video.video_url, {
        filename: filename
      })
      
      console.log('[VideosPage] ä¸‹è½½æœåŠ¡è°ƒç”¨å®Œæˆï¼Œæ›´æ–°ä¸‹è½½è®¡æ•°')
      await supabaseVideoService.incrementInteraction(video.id, 'download_count')
      
      // å»¶è¿Ÿæ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯ï¼Œç»™æµè§ˆå™¨æ—¶é—´å¼€å§‹ä¸‹è½½
      setTimeout(() => {
        toast.success('ä¸‹è½½å·²å¼€å§‹ï¼Œè¯·æŸ¥çœ‹æµè§ˆå™¨ä¸‹è½½åˆ—è¡¨', { 
          id: 'download-' + video.id,
          duration: 4000
        })
      }, 1000)
      
      loadVideos() // Reload to update download count
    } catch (error) {
      console.error('[VideosPage] ä¸‹è½½å¤±è´¥:', error)
      toast.error('ä¸‹è½½å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚å¦‚æœé—®é¢˜æŒç»­ï¼Œè¯·å°è¯•åœ¨æ–°çª—å£ä¸­å³é”®ä¿å­˜', { 
        id: 'download-' + video.id,
        duration: 5000
      })
    }
  }, [loadVideos]) // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šç¼“å­˜ä¸‹è½½å‡½æ•°

  const confirmDeleteVideo = React.useCallback(async () => {
    const videoToDelete = modals.delete.video
    if (!user || !videoToDelete) {
      console.error('[VideosPage] åˆ é™¤è§†é¢‘å¤±è´¥ï¼šç¼ºå°‘ç”¨æˆ·æˆ–è§†é¢‘ä¿¡æ¯')
      return
    }
    
    console.log(`[VideosPage] å¼€å§‹åˆ é™¤è§†é¢‘: ${videoToDelete.id}, ç”¨æˆ·: ${user.id}`)
    
    try {
      // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
      const loadingToast = toast.loading('æ­£åœ¨åˆ é™¤è§†é¢‘...')
      
      const success = await supabaseVideoService.hardDeleteVideo(videoToDelete.id, user.id)
      
      // å…³é—­åŠ è½½æç¤º
      toast.dismiss(loadingToast)
      
      if (success) {
        // 1. æ¸…ç†è¿›åº¦æ•°æ®
        console.log(`[VideosPage] æ¸…ç†å·²åˆ é™¤è§†é¢‘çš„è¿›åº¦æ•°æ®: ${videoToDelete.id}`)
        setVideoProgress(prev => {
          const newMap = new Map(prev)
          newMap.delete(videoToDelete.id)
          return newMap
        })
        
        // 2. æ¸…ç†progressManagerä¸­çš„æ•°æ®
        progressManager.clearProgress(videoToDelete.id)
        
        // 3. å–æ¶ˆè¯¥è§†é¢‘çš„æ‰€æœ‰è®¢é˜…
        const videoSubscription = activeSubscriptions.current.get(videoToDelete.id)
        if (videoSubscription) {
          videoSubscription()
          activeSubscriptions.current.delete(videoToDelete.id)
          console.log(`[VideosPage] å·²å–æ¶ˆæ•°æ®åº“è®¢é˜…: ${videoToDelete.id}`)
        }
        
        const progressSubscription = progressSubscriptions.current.get(videoToDelete.id)
        if (progressSubscription) {
          progressSubscription()
          progressSubscriptions.current.delete(videoToDelete.id)
          console.log(`[VideosPage] å·²å–æ¶ˆè¿›åº¦è®¢é˜…: ${videoToDelete.id}`)
        }
        
        // 4. é‡æ–°åŠ è½½è§†é¢‘åˆ—è¡¨
        await loadVideos()
        
        console.log(`[VideosPage] è§†é¢‘åˆ é™¤æˆåŠŸ: ${videoToDelete.id}`)
        toast.success('è§†é¢‘å·²åˆ é™¤')
      } else {
        console.error('[VideosPage] æ°¸ä¹…åˆ é™¤è§†é¢‘å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°è·å–è¯¦ç»†é”™è¯¯ä¿¡æ¯')
        toast.error('åˆ é™¤å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚å¦‚é—®é¢˜æŒç»­ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–è”ç³»å®¢æœã€‚')
      }
    } catch (error) {
      console.error('[VideosPage] åˆ é™¤è§†é¢‘è¿‡ç¨‹ä¸­å‡ºé”™:', error)
      toast.error('åˆ é™¤è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œè¯·é‡è¯•')
    } finally {
      setModals(prev => ({ 
        ...prev, 
        delete: { open: false, video: null }
      }))
    }
  }, [user, modals.delete.video, loadVideos]) // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šç¼“å­˜åˆ é™¤ç¡®è®¤å‡½æ•°

  const handleShare = async (platform: string) => {
    const selectedShareVideo = modals.share.video
    if (selectedShareVideo) {
      await videoShareService.shareVideo(selectedShareVideo.id, {
        platform: platform as any,
        title: selectedShareVideo.title || undefined
      })
      await supabaseVideoService.incrementInteraction(selectedShareVideo.id, 'share_count')
      setModals(prev => ({ ...prev, share: { open: false, video: null } }))
      loadVideos() // Reload to update share count
    }
  }

  return (
    <TooltipProvider>
    <div className="space-y-6 relative">
      {/* å®Œæˆé€šçŸ¥ */}
      {completionNotification.visible && completionNotification.video && (
        <div 
          className="fixed top-4 right-4 z-50 bg-gradient-to-r from-green-500 to-emerald-600 text-white px-6 py-4 rounded-lg shadow-xl animate-in slide-in-from-right-full duration-300 border border-green-400 cursor-pointer hover:shadow-2xl transition-shadow"
          onClick={() => {
            // ç‚¹å‡»é€šçŸ¥æ—¶æ’­æ”¾è§†é¢‘
            if (completionNotification.video) {
              handlePlayVideo(completionNotification.video)
              setCompletionNotification({ visible: false, video: null })
            }
          }}
        >
          <div className="flex items-center gap-3">
            <div className="w-3 h-3 bg-white rounded-full animate-ping"></div>
            <div>
              <div className="font-semibold flex items-center gap-2">
                ğŸ‰ è§†é¢‘ç”Ÿæˆå®Œæˆï¼
              </div>
              <div className="text-sm opacity-90">{completionNotification.video.title}</div>
              <div className="text-xs opacity-75 mt-1">
                {(() => {
                  // è®¡ç®—æ€»è€—æ—¶
                  if (completionNotification.video.processing_started_at && completionNotification.video.processing_completed_at) {
                    const startTime = new Date(completionNotification.video.processing_started_at).getTime()
                    const endTime = new Date(completionNotification.video.processing_completed_at).getTime()
                    const totalSeconds = Math.round((endTime - startTime) / 1000)
                    const timeStr = formatDuration(totalSeconds)
                    return `${t('videos.elapsedTime')}: ${timeStr} â€¢ ${t('common.view')}`
                  }
                  return t('common.view')
                })()}
              </div>
            </div>
          </div>
        </div>
      )}

      {/* ä»»åŠ¡æ¢å¤çŠ¶æ€æŒ‡ç¤ºå™¨ */}
      {(taskRecovery.isRecovering || taskRecovery.restoredCount > 0 || taskRecovery.resumedCount > 0) && (
        <div className="fixed top-4 left-4 z-50 bg-gradient-to-r from-blue-500 to-indigo-600 text-white px-4 py-3 rounded-lg shadow-xl animate-in slide-in-from-left-full duration-300 border border-blue-400">
          <div className="flex items-center gap-3">
            {taskRecovery.isRecovering ? (
              <>
                <Loader2 className="h-4 w-4 animate-spin" />
                <div className="text-sm font-medium">æ­£åœ¨æ¢å¤ä»»åŠ¡...</div>
              </>
            ) : (
              <>
                <div className="w-3 h-3 bg-white rounded-full animate-pulse"></div>
                <div className="text-sm">
                  <div className="font-medium">ä»»åŠ¡æ¢å¤å®Œæˆ</div>
                  <div className="text-xs opacity-90">
                    æ¢å¤è¿›åº¦: {taskRecovery.restoredCount} | æ¢å¤è½®è¯¢: {taskRecovery.resumedCount}
                  </div>
                </div>
              </>
            )}
          </div>
        </div>
      )}
      
      {/* Header */}
      <div className="flex justify-between items-start">
        <div>
          <h1 className="text-3xl font-bold">{t('video.myVideos')}</h1>
          <p className="text-muted-foreground mt-2">
            Manage and download your generated videos
          </p>
        </div>
        <Link to="/create">
          <Button>
            <Plus className="h-4 w-4 mr-2" />
            Create New Video
          </Button>
        </Link>
      </div>

      {/* Statistics Cards */}
      {statistics && (
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <Card>
            <CardContent className="p-4">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-muted-foreground">Total Videos</p>
                  <p className="text-2xl font-bold">{statistics.total}</p>
                </div>
                <TrendingUp className="h-8 w-8 text-muted-foreground" />
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-4">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-muted-foreground">Completed</p>
                  <p className="text-2xl font-bold text-green-600">{statistics.completed}</p>
                </div>
                <Eye className="h-8 w-8 text-green-600" />
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-4">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-muted-foreground">{t('videoCreator.processing')}</p>
                  <p className="text-2xl font-bold text-blue-600">{statistics.processing}</p>
                </div>
                <Clock className="h-8 w-8 text-blue-600" />
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-4">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-muted-foreground">Credits Used</p>
                  <p className="text-2xl font-bold">{statistics.totalCredits}</p>
                </div>
                <Calendar className="h-8 w-8 text-muted-foreground" />
              </div>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Filters and Search */}
      <div className="flex gap-4 flex-wrap">
        <div className="flex-1 min-w-[200px]">
          <div className="relative">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="Search videos..."
              value={uiState.searchTerm}
              onChange={(e) => setUiState(prev => ({ ...prev, searchTerm: e.target.value }))}
              className="pl-10"
            />
          </div>
        </div>
        
        <select
          className="px-3 py-2 border rounded-md"
          value={uiState.filter.status || ''}
          onChange={(e) => setUiState(prev => ({ ...prev, filter: { ...prev.filter, status: e.target.value as any } }))}
        >
          <option value="">All Status</option>
          <option value="completed">Completed</option>
          <option value="processing">Processing</option>
          <option value="pending">Pending</option>
          <option value="failed">Failed</option>
        </select>

        <div className="flex gap-2">
          <Button
            variant={uiState.viewMode === 'grid' ? 'default' : 'outline'}
            size="icon"
            onClick={() => setUiState(prev => ({ ...prev, viewMode: 'grid' }))}
          >
            <Grid className="h-4 w-4" />
          </Button>
          <Button
            variant={uiState.viewMode === 'list' ? 'default' : 'outline'}
            size="icon"
            onClick={() => setUiState(prev => ({ ...prev, viewMode: 'list' }))}
          >
            <List className="h-4 w-4" />
          </Button>
        </div>
      </div>

      {/* Videos Grid/List */}
      {uiState.loading ? (
        <div className="flex justify-center items-center py-12">
          <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
        </div>
      ) : filteredVideos.length === 0 ? (
        <Card className="text-center py-12">
          <CardContent>
            <p className="text-muted-foreground mb-4">
              {uiState.searchTerm || uiState.filter.status ? 'No videos found matching your criteria' : t('video.noVideos')}
            </p>
            <Link to="/create">
              <Button>{t('video.generateFirst')}</Button>
            </Link>
          </CardContent>
        </Card>
      ) : (
        <>
          <div className={uiState.viewMode === 'grid' ? 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4' : 'space-y-4'}>
            {filteredVideos.map((video) => {
              // Get template ID from metadata if not in template_id field
              const templateId = video.template_id || (video.metadata as any)?.templateId
              
              return (
                <EnhancedVideoCard
                  key={video.id}
                  video={video}
                  enableHoverPreview={true}
                  preloadDelay={500}
                  showStats={true}
                  compact={uiState.viewMode === 'list'}
                  onPlay={() => handlePlayVideo(video)}
                  onDownload={() => handleDownloadVideo(video)}
                  onShare={() => handleShareVideo(video)}
                  onSelect={() => handlePlayVideo(video)}
                  className="transition-all duration-300"
                />
              )
            })}
          </div>
        </>
      )}
    </TooltipProvider>
    
    {/* ä¿ç•™ç°æœ‰çš„æ¨¡æ€æ¡†ä»£ç  */}
    {/* Video Player Modal */}
    {modals.videoPlayer.open && modals.videoPlayer.video?.video_url && (
                <div className="aspect-video bg-muted relative group cursor-pointer" onClick={() => handlePlayVideo(video)}>
                  {video.status === 'completed' && video.video_url ? (
                    <LazyVideoPlayer
                      src={video.video_url}
                      poster={video.thumbnail_url || undefined}
                      className="w-full h-full"
                      objectFit="cover"
                      showPlayButton={true}
                      showVolumeControl={true}
                      autoPlayOnHover={false}
                      alt={video.title || 'Video preview'}
                      enableLazyLoad={true}
                      enableThumbnailCache={true}
                      enableNetworkAdaptive={false}
                      enableProgressiveLoading={true}
                    />
                  ) : video.thumbnail_url ? (
                    <img 
                      src={video.thumbnail_url} 
                      alt={video.title || 'Video thumbnail'}
                      className="w-full h-full object-cover"
                    />
                  ) : (
                    <div className="w-full h-full flex items-center justify-center bg-gray-100 dark:bg-gray-800">
                      {(video.status === 'processing' || video.status === 'pending') && !video.video_url ? (
                        // å¤„ç†ä¸­ï¼šå±…ä¸­æ˜¾ç¤ºåŠ è½½åŠ¨ç”»å’Œè¿›åº¦
                        <div className="text-center">
                          <Loader2 className="h-16 w-16 animate-spin text-blue-500 mx-auto mb-4" />
                          <div className="text-2xl font-bold text-gray-700 dark:text-gray-300 mb-2">
                            {(() => {
                              const progress = videoProgress.get(video.id)
                              return progress ? `${Math.round(progress.progress)}%` : '0%'
                            })()}
                          </div>
                          <div className="text-sm text-gray-500 dark:text-gray-400 mb-3">
                            {(() => {
                              const progress = videoProgress.get(video.id)
                              const statusText = progress?.statusText || (video.status === 'pending' ? t('videoCreator.preparing') : t('videoCreator.processing'))
                              
                              // æ˜¾ç¤ºè€—æ—¶ä¿¡æ¯
                              if (progress?.elapsedTime && progress.elapsedTime > 0) {
                                const minutes = Math.floor(progress.elapsedTime / 60)
                                const seconds = progress.elapsedTime % 60
                                const timeStr = minutes > 0 ? `${minutes}:${seconds.toString().padStart(2, '0')}` : `${seconds}s`
                                
                                // æ˜¾ç¤ºå‰©ä½™æ—¶é—´ä¼°ç®—
                                if (progress.estimatedRemainingTime && progress.estimatedRemainingTime > 10) {
                                  const remMinutes = Math.floor(progress.estimatedRemainingTime / 60)
                                  const remSeconds = progress.estimatedRemainingTime % 60
                                  const remTimeStr = remMinutes > 0 ? `${remMinutes}:${remSeconds.toString().padStart(2, '0')}` : `${remSeconds}s`
                                  return `${statusText} (${timeStr} / ~${remTimeStr})`
                                } else {
                                  return `${statusText} (${timeStr})`
                                }
                              }
                              
                              return statusText
                            })()}
                          </div>
                          {(() => {
                            const progress = videoProgress.get(video.id)
                            const percent = progress?.progress || 0
                            return percent > 0 && (
                              <div className="w-32 bg-gray-300 dark:bg-gray-600 rounded-full h-2 overflow-hidden">
                                <div 
                                  className="bg-gradient-to-r from-blue-500 to-blue-600 h-2 rounded-full transition-all duration-1000 ease-out"
                                  style={{ width: `${percent}%` }}
                                >
                                  {/* æ·»åŠ æµåŠ¨åŠ¨ç”»æ•ˆæœ */}
                                  <div className="h-full bg-gradient-to-r from-transparent via-white/20 to-transparent animate-pulse"></div>
                                </div>
                              </div>
                            )
                          })()}
                        </div>
                      ) : (
                        // å…¶ä»–çŠ¶æ€ï¼šæ˜¾ç¤ºå›¾æ ‡
                        <Eye className="h-12 w-12 text-muted-foreground" />
                      )}
                    </div>
                  )}
                  
                  {/* Overlay for click to play full screen */}
                  <div 
                    className="absolute inset-0 bg-transparent hover:bg-black/10 transition-colors flex items-center justify-center"
                    style={{ pointerEvents: video.status === 'completed' ? 'none' : 'auto' }}
                  >
                    {video.status === 'completed' && !video.video_url && (
                      <div className="opacity-0 group-hover:opacity-100 transition-opacity">
                        <Eye className="h-12 w-12 text-white drop-shadow-lg" />
                      </div>
                    )}
                  </div>
                </div>
                <CardContent className="p-3">
                  {/* Time and Template Info */}
                  <div className="flex items-center gap-2 text-xs text-muted-foreground">
                    <span className="flex items-center gap-1 flex-shrink-0">
                      <Clock className="h-3 w-3" />
                      {formatRelativeTime(video.created_at)}
                    </span>
                    {templateId && (
                      <>
                        <span className="text-muted-foreground/50">â€¢</span>
                        <span className="flex items-center gap-1 truncate min-w-0">
                          <Layers className="h-3 w-3 flex-shrink-0" />
                          <span className="truncate">{templates.find(t => t.id === templateId)?.name || t('video.customTemplate')}</span>
                        </span>
                      </>
                    )}
                  </div>
                  
                  <div className="flex justify-between items-center mt-2">
                    <div className="flex gap-2 text-sm text-muted-foreground">
                      <span className="flex items-center gap-1">
                        <Eye className="h-3 w-3" />
                        {video.view_count}
                      </span>
                      <span className="flex items-center gap-1">
                        <Download className="h-3 w-3" />
                        {video.download_count}
                      </span>
                    </div>
                    <div className="flex gap-1">
                      <Tooltip delayDuration={0}>
                        <TooltipTrigger asChild>
                          <Button 
                            size="icon" 
                            variant="ghost" 
                            onClick={(e) => { 
                              e.stopPropagation(); 
                              // å¦‚æœæœ‰ template_id åˆ™è·³è½¬åˆ°å¯¹åº”æ¨¡æ¿ï¼Œå¦åˆ™è·³è½¬åˆ°é»˜è®¤åˆ›å»ºé¡µ
                              if (templateId) {
                                // å°†è§†é¢‘çš„å‚æ•°ç¼–ç ä¸ºURLå‚æ•°ï¼Œä»¥ä¾¿åœ¨createé¡µé¢å¤ç”¨
                                const params = video.parameters || {};
                                const paramsStr = encodeURIComponent(JSON.stringify(params));
                                navigate(`/create?template=${templateId}&params=${paramsStr}`);
                              } else {
                                navigate('/create');
                              }
                            }}
                          >
                            <ArrowRight className="h-4 w-4" />
                          </Button>
                        </TooltipTrigger>
                        <TooltipContent>
                          <p>{templateId ? 'ä½¿ç”¨ç›¸åŒé…ç½®é‡æ–°ç”Ÿæˆ' : t('video.actions.createNew')}</p>
                        </TooltipContent>
                      </Tooltip>
                      
                      {video.video_url && (
                        <>
                          <Tooltip delayDuration={0}>
                            <TooltipTrigger asChild>
                              <Button size="icon" variant="ghost" onClick={(e) => { e.stopPropagation(); handleDownloadVideo(video); }}>
                                <Download className="h-4 w-4" />
                              </Button>
                            </TooltipTrigger>
                            <TooltipContent>
                              <p>{t('video.actions.download')}</p>
                            </TooltipContent>
                          </Tooltip>
                          
                          <Tooltip delayDuration={0}>
                            <TooltipTrigger asChild>
                              <Button size="icon" variant="ghost" onClick={(e) => { e.stopPropagation(); handleShareVideo(video); }}>
                                <Share2 className="h-4 w-4" />
                              </Button>
                            </TooltipTrigger>
                            <TooltipContent>
                              <p>{t('video.actions.share')}</p>
                            </TooltipContent>
                          </Tooltip>
                        </>
                      )}
                      
                      <Tooltip delayDuration={0}>
                        <TooltipTrigger asChild>
                          <Button size="icon" variant="ghost" onClick={(e) => { e.stopPropagation(); handleDeleteVideo(video); }}>
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </TooltipTrigger>
                        <TooltipContent>
                          <p>{t('video.actions.delete')}</p>
                        </TooltipContent>
                      </Tooltip>
                    </div>
                  </div>
                </CardContent>
              </Card>
            )})}
          </div>
          
          {/* Pagination */}
          {uiState.totalPages > 1 && (
            <div className="flex justify-center gap-2 mt-6">
              <Button 
                variant="outline" 
                onClick={() => setUiState(prev => ({ ...prev, page: Math.max(1, prev.page - 1) }))}
                disabled={uiState.page === 1}
              >
                ä¸Šä¸€é¡µ
              </Button>
              <span className="flex items-center px-4">
                ç¬¬ {uiState.page} / {uiState.totalPages} é¡µ
              </span>
              <Button 
                variant="outline"
                onClick={() => setUiState(prev => ({ ...prev, page: Math.min(prev.totalPages, prev.page + 1) }))}
                disabled={uiState.page === uiState.totalPages}
              >
                ä¸‹ä¸€é¡µ
              </Button>
            </div>
          )}
        </>
      )}

      {/* Video Player Modal */}
      {modals.videoPlayer.open && modals.videoPlayer.video?.video_url && (
        <div className="fixed inset-0 z-50 bg-black/80 flex items-center justify-center p-4">
          <div className="relative max-w-4xl w-full">
            <Button
              className="absolute -top-12 right-0 text-white"
              variant="ghost"
              onClick={() => setModals(prev => ({ ...prev, videoPlayer: { open: false, video: null } }))}
            >
              Close
            </Button>
            <LazyVideoPlayer
              src={modals.videoPlayer.video.video_url}
              poster={modals.videoPlayer.video.thumbnail_url || undefined}
              onDownload={() => handleDownloadVideo(modals.videoPlayer.video!)}
              onShare={() => handleShareVideo(modals.videoPlayer.video!)}
              enableLazyLoad={false}
              enableThumbnailCache={true}
              enableNetworkAdaptive={false}
              enableProgressiveLoading={true}
            />
          </div>
        </div>
      )}

      {/* Share Modal */}
      {modals.share.open && modals.share.video && (
        <div className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center p-4">
          <Card className="max-w-md w-full">
            <CardContent className="p-6">
              <h3 className="text-lg font-semibold mb-4">Share Video</h3>
              <div className="grid grid-cols-2 gap-3">
                <Button variant="outline" onClick={() => handleShare('twitter')}>
                  Twitter
                </Button>
                <Button variant="outline" onClick={() => handleShare('facebook')}>
                  Facebook
                </Button>
                <Button variant="outline" onClick={() => handleShare('linkedin')}>
                  LinkedIn
                </Button>
                <Button variant="outline" onClick={() => handleShare('whatsapp')}>
                  WhatsApp
                </Button>
                <Button variant="outline" onClick={() => handleShare('telegram')}>
                  Telegram
                </Button>
                <Button variant="outline" onClick={() => handleShare('copy')}>
                  Copy Link
                </Button>
              </div>
              <Button
                className="w-full mt-4"
                variant="outline"
                onClick={() => setModals(prev => ({ ...prev, share: { open: false, video: null } }))}
              >
                Cancel
              </Button>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Delete Confirmation Dialog */}
      <AlertDialog open={modals.delete.open} onOpenChange={(open) => !open && setModals(prev => ({ ...prev, delete: { open: false, video: null } }))}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>ç¡®è®¤åˆ é™¤</AlertDialogTitle>
            <AlertDialogDescription>
              ç¡®å®šè¦åˆ é™¤è§†é¢‘ "{modals.delete.video?.title || 'æœªå‘½åè§†é¢‘'}" å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={() => setModals(prev => ({ ...prev, delete: { open: false, video: null } }))}>å–æ¶ˆ</AlertDialogCancel>
            <AlertDialogAction 
              onClick={confirmDeleteVideo}
              className="bg-red-600 hover:bg-red-700"
            >
              åˆ é™¤
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
    </TooltipProvider>
  )
}
