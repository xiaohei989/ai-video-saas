<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ”¥ ç»ˆæç¼“å­˜æ¸…ç†å·¥å…·</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
        }
        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .subtitle {
            text-align: center;
            opacity: 0.9;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        .warning {
            background: rgba(255, 152, 0, 0.2);
            border: 2px solid rgba(255, 152, 0, 0.5);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }
        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        .clear-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: none;
            color: white;
            padding: 20px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .clear-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        .nuclear-btn {
            background: linear-gradient(45deg, #c0392b, #e74c3c);
            font-size: 18px;
            padding: 25px;
        }
        .status {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid;
        }
        .success { border-left-color: #2ecc71; }
        .error { border-left-color: #e74c3c; }
        .info { border-left-color: #3498db; }
        .warning-status { border-left-color: #f39c12; }
        
        .progress-bar {
            background: rgba(255, 255, 255, 0.2);
            height: 8px;
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }
        .progress-fill {
            background: linear-gradient(45deg, #2ecc71, #27ae60);
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 12px;
            text-align: center;
        }
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”¥ ç»ˆæç¼“å­˜æ¸…ç†å·¥å…·</h1>
        <p class="subtitle">å½»åº•æ¸…é™¤æ‰€æœ‰ä½è´¨é‡ç¼“å­˜ï¼Œç¡®ä¿åªä¿ç•™é«˜è´¨é‡å›¾ç‰‡</p>
        
        <div class="warning">
            <h3>âš ï¸ é‡è¦æé†’</h3>
            <p>æ­¤å·¥å…·å°†å½»åº•æ¸…é™¤æ‰€æœ‰æœ¬åœ°ç¼“å­˜æ•°æ®ï¼ŒåŒ…æ‹¬å›¾ç‰‡ã€æ¨¡æ¿ã€ç”¨æˆ·æ•°æ®ç­‰ã€‚</p>
            <p>æ¸…ç†åç³»ç»Ÿå°†é‡æ–°è·å–é«˜è´¨é‡å†…å®¹ï¼Œé¦–æ¬¡åŠ è½½å¯èƒ½ç¨æ…¢ã€‚</p>
        </div>

        <div class="stats-grid" id="currentStats">
            <div class="stat-card">
                <div class="stat-number" id="dbCount">-</div>
                <div>æ•°æ®åº“æ•°é‡</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="storageUsed">-</div>
                <div>å­˜å‚¨å ç”¨</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="cacheItems">-</div>
                <div>ç¼“å­˜é¡¹ç›®</div>
            </div>
        </div>

        <div class="button-grid">
            <button class="clear-btn" onclick="clearLowQualityCache()">
                ğŸ—‘ï¸ æ¸…ç†ä½è´¨é‡ç¼“å­˜<br>
                <small>åªåˆ é™¤ <20KB çš„ä½è´¨é‡å›¾ç‰‡ç¼“å­˜</small>
            </button>
            
            <button class="clear-btn" onclick="clearImageCache()">
                ğŸ–¼ï¸ æ¸…ç†å›¾ç‰‡ç¼“å­˜<br>
                <small>æ¸…ç†æ‰€æœ‰å›¾ç‰‡ç›¸å…³ç¼“å­˜</small>
            </button>
            
            <button class="clear-btn" onclick="clearIndexedDBCache()">
                ğŸ’¾ æ¸…ç†IndexedDB<br>
                <small>æ¸…ç†æ‰€æœ‰IndexedDBæ•°æ®åº“</small>
            </button>
            
            <button class="clear-btn" onclick="clearBrowserCache()">
                ğŸŒ æ¸…ç†æµè§ˆå™¨ç¼“å­˜<br>
                <small>æ¸…ç†localStorage + sessionStorage</small>
            </button>
            
            <button class="clear-btn nuclear-btn" onclick="nuclearClean()">
                â˜¢ï¸ æ ¸å¼¹çº§æ¸…ç†<br>
                <small>æ¸…ç†ä¸€åˆ‡å¯èƒ½çš„ç¼“å­˜æ•°æ®</small>
            </button>
        </div>

        <div class="progress-bar" id="progressContainer" style="display: none;">
            <div class="progress-fill" id="progressBar" style="width: 0%"></div>
        </div>

        <div id="results"></div>
    </div>

    <script>
        let totalDatabases = 0;
        let currentProgress = 0;

        // é¡µé¢åŠ è½½æ—¶è·å–å½“å‰çŠ¶æ€
        window.addEventListener('load', () => {
            updateCurrentStats();
        });

        async function updateCurrentStats() {
            try {
                const stats = await getCacheStats();
                document.getElementById('dbCount').textContent = stats.databases;
                document.getElementById('storageUsed').textContent = stats.storage;
                document.getElementById('cacheItems').textContent = stats.items;
            } catch (error) {
                console.error('è·å–ç»Ÿè®¡å¤±è´¥:', error);
            }
        }

        async function getCacheStats() {
            const databases = await indexedDB.databases();
            const dbCount = databases.length;
            
            let storageUsed = 'æœªçŸ¥';
            let cacheItems = 0;
            
            try {
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    const estimate = await navigator.storage.estimate();
                    storageUsed = (estimate.usage / 1024 / 1024).toFixed(1) + 'MB';
                }
                
                // ä¼°ç®—localStorageé¡¹ç›®æ•°
                cacheItems = Object.keys(localStorage).length;
            } catch (e) {
                console.warn('è·å–å­˜å‚¨ç»Ÿè®¡å¤±è´¥:', e);
            }
            
            return {
                databases: dbCount,
                storage: storageUsed,
                items: cacheItems
            };
        }

        function showProgress() {
            document.getElementById('progressContainer').style.display = 'block';
            updateProgress(0);
        }

        function hideProgress() {
            document.getElementById('progressContainer').style.display = 'none';
        }

        function updateProgress(percentage) {
            document.getElementById('progressBar').style.width = percentage + '%';
        }

        function logResult(message, type = 'info') {
            const resultsDiv = document.getElementById('results');
            const statusDiv = document.createElement('div');
            statusDiv.className = `status ${type}`;
            statusDiv.innerHTML = message;
            resultsDiv.appendChild(statusDiv);
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }

        async function clearLowQualityCache() {
            logResult('ğŸ” å¼€å§‹æ™ºèƒ½æ¸…ç†ä½è´¨é‡ç¼“å­˜...', 'info');
            showProgress();

            let cleanedCount = 0;
            let totalChecked = 0;

            try {
                // 1. æ¸…ç†localStorageä¸­çš„ä½è´¨é‡Base64å›¾ç‰‡
                logResult('ğŸ“Š åˆ†ælocalStorageä¸­çš„å›¾ç‰‡ç¼“å­˜...', 'info');
                updateProgress(20);

                const keys = Object.keys(localStorage);
                for (const key of keys) {
                    if (key.includes('img_') || key.includes('cache') || key.includes('thumb')) {
                        try {
                            const data = localStorage.getItem(key);
                            if (data && data.startsWith('data:image')) {
                                const base64Part = data.split(',')[1];
                                if (base64Part) {
                                    const sizeKB = (base64Part.length * 0.75 / 1024);
                                    totalChecked++;
                                    
                                    if (sizeKB < 20) { // ä½äº20KBè®¤ä¸ºæ˜¯ä½è´¨é‡
                                        localStorage.removeItem(key);
                                        cleanedCount++;
                                        logResult(`ğŸ—‘ï¸ åˆ é™¤ä½è´¨é‡ç¼“å­˜: ${key.substring(0, 50)}... (${sizeKB.toFixed(2)}KB)`, 'success');
                                    }
                                }
                            }
                        } catch (e) {
                            console.warn('å¤„ç†é”®å¤±è´¥:', key, e);
                        }
                    }
                }

                updateProgress(60);

                // 2. æ¸…ç†IndexedDBä¸­çš„ä½è´¨é‡ç¼“å­˜
                logResult('ğŸ’¾ æ¸…ç†IndexedDBä¸­çš„ä½è´¨é‡ç¼“å­˜...', 'info');
                
                const databases = await indexedDB.databases();
                for (const db of databases) {
                    if (db.name && (db.name.includes('cache') || db.name.includes('image'))) {
                        try {
                            await deleteDatabase(db.name);
                            logResult(`âœ… æ¸…ç†æ•°æ®åº“: ${db.name}`, 'success');
                            cleanedCount++;
                        } catch (error) {
                            logResult(`âš ï¸ æ¸…ç†æ•°æ®åº“å¤±è´¥: ${db.name} - ${error.message}`, 'warning-status');
                        }
                    }
                }

                updateProgress(100);

                logResult(`ğŸ‰ ä½è´¨é‡ç¼“å­˜æ¸…ç†å®Œæˆï¼`, 'success');
                logResult(`ğŸ“Š ç»Ÿè®¡: æ£€æŸ¥äº†${totalChecked}ä¸ªé¡¹ç›®ï¼Œæ¸…ç†äº†${cleanedCount}ä¸ªä½è´¨é‡ç¼“å­˜`, 'info');
                
            } catch (error) {
                logResult(`âŒ æ¸…ç†è¿‡ç¨‹ä¸­å‡ºé”™: ${error.message}`, 'error');
            } finally {
                hideProgress();
                await updateCurrentStats();
            }
        }

        async function clearImageCache() {
            logResult('ğŸ–¼ï¸ å¼€å§‹æ¸…ç†æ‰€æœ‰å›¾ç‰‡ç¼“å­˜...', 'info');
            showProgress();

            let cleanedCount = 0;

            try {
                // æ¸…ç†localStorageå›¾ç‰‡ç¼“å­˜
                updateProgress(25);
                const keys = Object.keys(localStorage);
                for (const key of keys) {
                    if (key.includes('img_') || key.includes('image') || key.includes('thumb') || key.includes('template')) {
                        localStorage.removeItem(key);
                        cleanedCount++;
                    }
                }
                logResult(`ğŸ—‘ï¸ æ¸…ç†localStorageå›¾ç‰‡ç¼“å­˜: ${cleanedCount}ä¸ª`, 'success');

                updateProgress(50);

                // æ¸…ç†ç›¸å…³æ•°æ®åº“
                const imageDatabases = [
                    'ai-video-saas-cache',
                    'image-cache',
                    'template-cache',
                    'thumbnail-cache',
                    'unified-cache',
                    'unified-cache-v1'
                ];

                let dbCleaned = 0;
                for (const dbName of imageDatabases) {
                    try {
                        await deleteDatabase(dbName);
                        dbCleaned++;
                        logResult(`âœ… æ¸…ç†å›¾ç‰‡æ•°æ®åº“: ${dbName}`, 'success');
                    } catch (error) {
                        logResult(`âš ï¸ æ•°æ®åº“ä¸å­˜åœ¨æˆ–å·²æ¸…ç†: ${dbName}`, 'info');
                    }
                }

                updateProgress(100);
                logResult(`ğŸ‰ å›¾ç‰‡ç¼“å­˜æ¸…ç†å®Œæˆï¼æ¸…ç†äº†${cleanedCount}ä¸ªå­˜å‚¨é¡¹å’Œ${dbCleaned}ä¸ªæ•°æ®åº“`, 'success');

            } catch (error) {
                logResult(`âŒ æ¸…ç†å›¾ç‰‡ç¼“å­˜å¤±è´¥: ${error.message}`, 'error');
            } finally {
                hideProgress();
                await updateCurrentStats();
            }
        }

        async function clearIndexedDBCache() {
            logResult('ğŸ’¾ å¼€å§‹æ¸…ç†æ‰€æœ‰IndexedDBæ•°æ®åº“...', 'info');
            showProgress();

            try {
                const databases = await indexedDB.databases();
                totalDatabases = databases.length;
                
                if (totalDatabases === 0) {
                    logResult('âœ… æœªå‘ç°IndexedDBæ•°æ®åº“', 'info');
                    hideProgress();
                    return;
                }

                logResult(`ğŸ” å‘ç° ${totalDatabases} ä¸ªæ•°æ®åº“ï¼Œå¼€å§‹æ¸…ç†...`, 'info');

                let cleaned = 0;
                for (let i = 0; i < databases.length; i++) {
                    const db = databases[i];
                    try {
                        await deleteDatabase(db.name);
                        cleaned++;
                        logResult(`âœ… å·²åˆ é™¤: ${db.name} (ç‰ˆæœ¬ ${db.version})`, 'success');
                    } catch (error) {
                        logResult(`âŒ åˆ é™¤å¤±è´¥: ${db.name} - ${error.message}`, 'error');
                    }
                    updateProgress(((i + 1) / totalDatabases) * 100);
                }

                logResult(`ğŸ‰ IndexedDBæ¸…ç†å®Œæˆï¼æˆåŠŸæ¸…ç† ${cleaned}/${totalDatabases} ä¸ªæ•°æ®åº“`, 'success');

            } catch (error) {
                logResult(`âŒ IndexedDBæ¸…ç†å¤±è´¥: ${error.message}`, 'error');
            } finally {
                hideProgress();
                await updateCurrentStats();
            }
        }

        async function clearBrowserCache() {
            logResult('ğŸŒ å¼€å§‹æ¸…ç†æµè§ˆå™¨å­˜å‚¨ç¼“å­˜...', 'info');
            showProgress();

            try {
                // æ¸…ç†localStorage
                updateProgress(25);
                const localStorageCount = Object.keys(localStorage).length;
                localStorage.clear();
                logResult(`âœ… æ¸…ç†localStorage: ${localStorageCount}ä¸ªé¡¹ç›®`, 'success');

                // æ¸…ç†sessionStorage
                updateProgress(50);
                const sessionStorageCount = Object.keys(sessionStorage).length;
                sessionStorage.clear();
                logResult(`âœ… æ¸…ç†sessionStorage: ${sessionStorageCount}ä¸ªé¡¹ç›®`, 'success');

                // æ¸…ç†Cache API (å¦‚æœæ”¯æŒ)
                updateProgress(75);
                if ('caches' in window) {
                    const cacheNames = await caches.keys();
                    let deletedCaches = 0;
                    for (const cacheName of cacheNames) {
                        await caches.delete(cacheName);
                        deletedCaches++;
                    }
                    logResult(`âœ… æ¸…ç†Cache API: ${deletedCaches}ä¸ªç¼“å­˜`, 'success');
                }

                updateProgress(100);
                logResult('ğŸ‰ æµè§ˆå™¨å­˜å‚¨ç¼“å­˜æ¸…ç†å®Œæˆï¼', 'success');

            } catch (error) {
                logResult(`âŒ æµè§ˆå™¨ç¼“å­˜æ¸…ç†å¤±è´¥: ${error.message}`, 'error');
            } finally {
                hideProgress();
                await updateCurrentStats();
            }
        }

        async function nuclearClean() {
            const confirmed = confirm('âš ï¸ æ ¸å¼¹çº§æ¸…ç†å°†åˆ é™¤æ‰€æœ‰å¯èƒ½çš„ç¼“å­˜æ•°æ®ï¼\nè¿™åŒ…æ‹¬:\n- æ‰€æœ‰IndexedDBæ•°æ®åº“\n- æ‰€æœ‰localStorageæ•°æ®\n- æ‰€æœ‰sessionStorageæ•°æ®\n- æ‰€æœ‰Cache APIæ•°æ®\n\nç¡®å®šè¦ç»§ç»­å—ï¼Ÿ');
            
            if (!confirmed) return;

            logResult('â˜¢ï¸ å¯åŠ¨æ ¸å¼¹çº§æ¸…ç†æ¨¡å¼...', 'warning-status');
            showProgress();

            let totalCleaned = 0;

            try {
                // æ­¥éª¤1: æ¸…ç†æ‰€æœ‰IndexedDB
                logResult('ğŸ”¥ ç¬¬ä¸€æ³¢ï¼šæ¸…ç†æ‰€æœ‰IndexedDBæ•°æ®åº“...', 'info');
                updateProgress(20);
                
                const databases = await indexedDB.databases();
                for (const db of databases) {
                    try {
                        await deleteDatabase(db.name);
                        totalCleaned++;
                        logResult(`ğŸ’¥ æ‘§æ¯æ•°æ®åº“: ${db.name}`, 'success');
                    } catch (error) {
                        logResult(`âš ï¸ æ‘§æ¯å¤±è´¥: ${db.name}`, 'warning-status');
                    }
                }

                // æ­¥éª¤2: æ¸…ç†æ‰€æœ‰å­˜å‚¨
                updateProgress(40);
                logResult('ğŸ”¥ ç¬¬äºŒæ³¢ï¼šæ¸…ç†æ‰€æœ‰æµè§ˆå™¨å­˜å‚¨...', 'info');
                
                const localCount = Object.keys(localStorage).length;
                const sessionCount = Object.keys(sessionStorage).length;
                localStorage.clear();
                sessionStorage.clear();
                totalCleaned += localCount + sessionCount;
                logResult(`ğŸ’¥ æ‘§æ¯å­˜å‚¨: ${localCount + sessionCount}ä¸ªé¡¹ç›®`, 'success');

                // æ­¥éª¤3: æ¸…ç†Cache API
                updateProgress(60);
                logResult('ğŸ”¥ ç¬¬ä¸‰æ³¢ï¼šæ¸…ç†Cache API...', 'info');
                
                if ('caches' in window) {
                    const cacheNames = await caches.keys();
                    for (const cacheName of cacheNames) {
                        await caches.delete(cacheName);
                        totalCleaned++;
                    }
                    logResult(`ğŸ’¥ æ‘§æ¯ç¼“å­˜: ${cacheNames.length}ä¸ª`, 'success');
                }

                // æ­¥éª¤4: å¼ºåˆ¶åƒåœ¾å›æ”¶
                updateProgress(80);
                logResult('ğŸ”¥ ç¬¬å››æ³¢ï¼šå¼ºåˆ¶åƒåœ¾å›æ”¶...', 'info');
                
                if (window.gc) {
                    window.gc();
                    logResult('ğŸ’¥ æ‰§è¡Œåƒåœ¾å›æ”¶', 'success');
                }

                // æ­¥éª¤5: æ¸…ç†å¯èƒ½æ®‹ç•™çš„æ•°æ®
                updateProgress(90);
                logResult('ğŸ”¥ æœ€åä¸€æ³¢ï¼šæ¸…ç†æ®‹ç•™æ•°æ®...', 'info');
                
                const commonDbNames = [
                    'keyval-store',
                    'workbox-runtime',
                    'workbox-expiration',
                    'template-cache',
                    'thumbnail-cache',
                    'video-cache',
                    'image-cache',
                    'ai-video-cache',
                    'supabase-cache',
                    'unified-cache',
                    'unified-cache-v1',
                    'ai-video-saas-cache'
                ];

                for (const dbName of commonDbNames) {
                    try {
                        await deleteDatabase(dbName);
                        logResult(`ğŸ’¥ å¼ºåˆ¶æ¸…ç†: ${dbName}`, 'success');
                    } catch (e) {
                        // å¿½ç•¥ä¸å­˜åœ¨çš„æ•°æ®åº“
                    }
                }

                updateProgress(100);
                logResult('â˜¢ï¸ æ ¸å¼¹çº§æ¸…ç†å®Œæˆï¼æ‰€æœ‰ç¼“å­˜å·²è¢«æ‘§æ¯ï¼', 'success');
                logResult(`ğŸ“Š æ€»è®¡æ¸…ç†: ${totalCleaned}ä¸ªé¡¹ç›®`, 'info');
                logResult('ğŸ’¡ å»ºè®®åˆ·æ–°é¡µé¢æˆ–é‡å¯æµè§ˆå™¨ä»¥ç¡®ä¿å®Œå…¨æ¸…ç†', 'warning-status');

                // è‡ªåŠ¨åˆ·æ–°ç¡®è®¤
                setTimeout(() => {
                    if (confirm('æ ¸å¼¹çº§æ¸…ç†å®Œæˆï¼æ˜¯å¦ç«‹å³åˆ·æ–°é¡µé¢ä»¥ç¡®ä¿å®Œå…¨æ¸…ç†ï¼Ÿ')) {
                        location.reload();
                    }
                }, 3000);

            } catch (error) {
                logResult(`âŒ æ ¸å¼¹çº§æ¸…ç†è¿‡ç¨‹ä¸­å‡ºé”™: ${error.message}`, 'error');
            } finally {
                hideProgress();
                await updateCurrentStats();
            }
        }

        function deleteDatabase(name) {
            return new Promise((resolve, reject) => {
                const deleteReq = indexedDB.deleteDatabase(name);
                
                deleteReq.onerror = () => reject(deleteReq.error);
                deleteReq.onsuccess = () => resolve();
                deleteReq.onblocked = () => {
                    // ç­‰å¾…ä¸€ç‚¹æ—¶é—´è®©å…¶ä»–è¿æ¥å…³é—­
                    setTimeout(() => resolve(), 1000);
                };
                
                // è®¾ç½®è¶…æ—¶
                setTimeout(() => {
                    reject(new Error(`åˆ é™¤æ•°æ®åº“ ${name} è¶…æ—¶`));
                }, 10000);
            });
        }
    </script>
</body>
</html>