<!DOCTYPE html>
<html>
<head>
    <title>æ¸…é™¤ç¼“å­˜</title>
    <meta charset="utf-8">
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .log { background: #f5f5f5; padding: 10px; margin: 10px 0; border-radius: 5px; }
        .success { color: green; }
        .error { color: red; }
        .warning { color: orange; }
        button { background: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; }
        button:hover { background: #0056b3; }
    </style>
</head>
<body>
    <h1>ğŸ§¹ å¼ºåˆ¶æ¸…é™¤æœ¬åœ°ç¼“å­˜</h1>
    <p>ç‚¹å‡»æŒ‰é’®æ¸…é™¤æ‰€æœ‰IndexedDBã€LocalStorageå’Œå…¶ä»–ç¼“å­˜æ•°æ®</p>
    
    <div style="margin: 20px 0;">
        <button onclick="clearAllCache()">ğŸ—‘ï¸ ç«‹å³æ¸…é™¤æ‰€æœ‰ç¼“å­˜</button>
        <button onclick="clearNewImageCache()" style="margin-left: 10px; background: #dc3545;">ğŸ”¥ å¼ºåŠ›æ¸…ç†å›¾ç‰‡ç¼“å­˜</button>
        <button onclick="clearSpecificCache()" style="margin-left: 10px; background: #28a745;">ğŸ¯ ç²¾å‡†æ¸…ç†åº”ç”¨ç¼“å­˜</button>
    </div>
    
    <div id="log"></div>

    <script>
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log')
            const p = document.createElement('p')
            p.className = type
            p.textContent = new Date().toLocaleTimeString() + ' - ' + message
            logDiv.appendChild(p)
            console.log(message)
        }

        async function clearAllCache() {
            log('ğŸ§¹ å¼€å§‹å¼ºåˆ¶æ¸…é™¤æ‰€æœ‰ç¼“å­˜...', 'info')
            
            try {
                // 1. æ¸…é™¤IndexedDB
                const databases = [
                    'ai-video-unified-cache', // ğŸ¯ æ–°çš„ç»Ÿä¸€ç¼“å­˜æ•°æ®åº“ï¼
                    'ai-video-saas-cache',    // ğŸ—‘ï¸ æ—§æ•°æ®åº“ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                    'UnifiedCache', 
                    'ImageCache', 
                    'TemplateCache', 
                    'VideoCache', 
                    'ai-video-cache', 
                    'template-cache', 
                    'idb-cache'
                ]
                
                for (const dbName of databases) {
                    try {
                        log(`æ­£åœ¨åˆ é™¤æ•°æ®åº“: ${dbName}`)
                        
                        const deleteRequest = indexedDB.deleteDatabase(dbName)
                        
                        await new Promise((resolve) => {
                            deleteRequest.onsuccess = () => {
                                log(`âœ… æ•°æ®åº“ ${dbName} åˆ é™¤æˆåŠŸ`, 'success')
                                resolve()
                            }
                            
                            deleteRequest.onerror = () => {
                                log(`âš ï¸ æ•°æ®åº“ ${dbName} åˆ é™¤å¤±è´¥æˆ–ä¸å­˜åœ¨`, 'warning')
                                resolve()
                            }
                            
                            deleteRequest.onblocked = () => {
                                log(`ğŸ”’ æ•°æ®åº“ ${dbName} åˆ é™¤è¢«é˜»å¡`, 'warning')
                                resolve()
                            }
                        })
                        
                        await new Promise(resolve => setTimeout(resolve, 100))
                    } catch (error) {
                        log(`åˆ é™¤æ•°æ®åº“ ${dbName} æ—¶å‡ºé”™: ${error.message}`, 'error')
                    }
                }

                // 2. æ¸…é™¤LocalStorage
                log('æ¸…é™¤LocalStorageç¼“å­˜...')
                const keysToRemove = []
                
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i)
                    if (key && (
                        key.startsWith('cached_img_') ||
                        key.startsWith('template_') ||
                        key.startsWith('video_') ||
                        key.startsWith('img_') ||
                        key.includes('cache') ||
                        key.includes('thumbnail')
                    )) {
                        keysToRemove.push(key)
                    }
                }
                
                keysToRemove.forEach(key => {
                    localStorage.removeItem(key)
                })
                
                log(`âœ… æ¸…é™¤äº† ${keysToRemove.length} ä¸ªLocalStorageé”®`, 'success')

                // 3. æ¸…é™¤SessionStorage
                log('æ¸…é™¤SessionStorageç¼“å­˜...')
                const sessionKeysToRemove = []
                
                for (let i = 0; i < sessionStorage.length; i++) {
                    const key = sessionStorage.key(i)
                    if (key && (
                        key.includes('cache') ||
                        key.includes('thumbnail') ||
                        key.includes('image')
                    )) {
                        sessionKeysToRemove.push(key)
                    }
                }
                
                sessionKeysToRemove.forEach(key => {
                    sessionStorage.removeItem(key)
                })
                
                log(`âœ… æ¸…é™¤äº† ${sessionKeysToRemove.length} ä¸ªSessionStorageé”®`, 'success')

                // 4. æ¸…é™¤Cache API
                if ('caches' in window) {
                    log('æ¸…é™¤Cache API...')
                    const cacheNames = await caches.keys()
                    let deletedCaches = 0
                    
                    for (const cacheName of cacheNames) {
                        if (cacheName.includes('image') || cacheName.includes('template') || cacheName.includes('thumbnail')) {
                            await caches.delete(cacheName)
                            deletedCaches++
                        }
                    }
                    
                    log(`âœ… æ¸…é™¤äº† ${deletedCaches} ä¸ªCache`, 'success')
                }

                log('ğŸ‰ æ‰€æœ‰ç¼“å­˜æ¸…é™¤å®Œæˆ!', 'success')
                log('ğŸ’¡ å»ºè®®åˆ·æ–°é¡µé¢é‡æ–°åŠ è½½ç³»ç»Ÿ', 'info')
                
                // è‡ªåŠ¨åˆ·æ–°é¡µé¢
                setTimeout(() => {
                    if (confirm('ç¼“å­˜æ¸…é™¤å®Œæˆï¼æ˜¯å¦ç«‹å³åˆ·æ–°é¡µé¢ï¼Ÿ')) {
                        location.reload()
                    }
                }, 2000)

            } catch (error) {
                log(`âŒ ç¼“å­˜æ¸…é™¤è¿‡ç¨‹ä¸­å‡ºé”™: ${error.message}`, 'error')
            }
        }

        async function clearNewImageCache() {
            log('ğŸ”¥ å¼€å§‹å¼ºåŠ›æ¸…ç†NewImageCacheç¼“å­˜...', 'info')
            
            try {
                let clearedCount = 0
                
                // æ¸…ç†æ‰€æœ‰å¯èƒ½çš„IndexedDBæ•°æ®åº“ï¼ˆåŒ…å«çœŸæ­£çš„ç¼“å­˜æ•°æ®åº“ï¼‰
                const targetDatabases = [
                    'ai-video-unified-cache',  // ğŸ¯ æ–°çš„ç»Ÿä¸€ç¼“å­˜æ•°æ®åº“ï¼
                    'ai-video-saas-cache',     // ğŸ—‘ï¸ æ—§æ•°æ®åº“ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                    'unified-cache-v1',
                    'unified-cache', 
                    'image-cache',
                    'template-cache',
                    'thumbnail-cache',
                    'newImageCache',
                    'keyval-store'
                ]
                
                log('ğŸ¯ ä¸“é—¨æ¸…ç†NewImageCacheç›¸å…³æ•°æ®åº“...', 'info')
                
                for (const dbName of targetDatabases) {
                    try {
                        await new Promise((resolve, reject) => {
                            const deleteReq = indexedDB.deleteDatabase(dbName)
                            deleteReq.onerror = () => reject(deleteReq.error)
                            deleteReq.onsuccess = () => resolve()
                            deleteReq.onblocked = () => setTimeout(resolve, 1000)
                            setTimeout(() => reject(new Error('timeout')), 5000)
                        })
                        
                        log(`âœ… å·²åˆ é™¤: ${dbName}`, 'success')
                        clearedCount++
                    } catch (error) {
                        log(`âš ï¸ æ¸…ç†: ${dbName} (${error.message})`, 'warning')
                    }
                }
                
                // æ¸…ç†localStorageä¸­çš„å›¾ç‰‡ç¼“å­˜ç›¸å…³é¡¹
                log('ğŸ§¹ æ¸…ç†localStorageä¸­çš„å›¾ç‰‡ç¼“å­˜...', 'info')
                const keys = Object.keys(localStorage)
                let localStorageCleared = 0
                
                keys.forEach(key => {
                    if (key.includes('img_') || 
                        key.includes('image') || 
                        key.includes('thumbnail') || 
                        key.includes('template') ||
                        key.includes('cache')) {
                        localStorage.removeItem(key)
                        localStorageCleared++
                    }
                })
                
                log(`âœ… æ¸…ç†localStorageé¡¹: ${localStorageCleared}ä¸ª`, 'success')
                
                // æ¸…ç†sessionStorage
                sessionStorage.clear()
                log('âœ… æ¸…ç†sessionStorage', 'success')
                
                // å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼ˆå¦‚æœæ”¯æŒï¼‰
                if (window.gc) {
                    window.gc()
                    log('âœ… æ‰§è¡Œåƒåœ¾å›æ”¶', 'success')
                }
                
                log('ğŸ‰ NewImageCacheå¼ºåŠ›æ¸…ç†å®Œæˆï¼', 'success')
                log(`ğŸ“Š æ¸…ç†ç»Ÿè®¡ï¼šIndexedDBæ•°æ®åº“ ${clearedCount}ä¸ªï¼ŒlocalStorageé¡¹ ${localStorageCleared}ä¸ª`, 'info')
                log('ğŸ’¡ å»ºè®®åˆ·æ–°é¡µé¢æˆ–é‡å¯æµè§ˆå™¨ä»¥ç¡®ä¿å®Œå…¨æ¸…ç†', 'info')
                
                // å»¶è¿Ÿæç¤ºåˆ·æ–°
                setTimeout(() => {
                    if (confirm('NewImageCacheæ¸…ç†å®Œæˆï¼å»ºè®®åˆ·æ–°é¡µé¢ç¡®ä¿å®Œå…¨æ¸…ç†ï¼Œæ˜¯å¦ç«‹å³åˆ·æ–°ï¼Ÿ')) {
                        location.reload()
                    }
                }, 1500)
                
            } catch (error) {
                log(`âŒ NewImageCacheæ¸…ç†è¿‡ç¨‹å‡ºé”™: ${error.message}`, 'error')
            }
        }

        async function clearSpecificCache() {
            log('ğŸ¯ å¼€å§‹ç²¾å‡†æ¸…ç†åº”ç”¨ç¼“å­˜...', 'info')
            
            try {
                // ç›®æ ‡åº”ç”¨ç¼“å­˜æ•°æ®åº“
                const appDatabases = [
                    'ai-video-unified-cache', // ğŸ¯ æ–°çš„ç»Ÿä¸€ç¼“å­˜æ•°æ®åº“ï¼
                    'ai-video-saas-cache',    // ğŸ—‘ï¸ æ—§æ•°æ®åº“ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                    'template-cache',
                    'thumbnail-cache', 
                    'video-cache',
                    'image-cache',
                    'ai-video-saas',
                    'supabase-cache',
                    'webp-cache'
                ]

                let clearedCount = 0
                let errors = []

                for (const dbName of appDatabases) {
                    try {
                        await new Promise((resolve, reject) => {
                            const deleteReq = indexedDB.deleteDatabase(dbName)
                            deleteReq.onerror = () => reject(deleteReq.error)
                            deleteReq.onsuccess = () => resolve()
                            deleteReq.onblocked = () => setTimeout(resolve, 1000)
                            setTimeout(() => reject(new Error('timeout')), 3000)
                        })
                        
                        clearedCount++
                        log(`âœ… å·²æ¸…ç†: ${dbName}`, 'success')
                    } catch (error) {
                        if (!error.message.includes('not found') && !error.message.includes('timeout')) {
                            errors.push(`${dbName}: ${error.message}`)
                            log(`âš ï¸ æ¸…ç†å¤±è´¥: ${dbName} - ${error.message}`, 'warning')
                        }
                    }
                }

                // æ¸…ç†ç‰¹å®šçš„localStorageé¡¹
                log('ğŸ” æ¸…ç†åº”ç”¨ç›¸å…³localStorageé¡¹...', 'info')
                const storageKeys = Object.keys(localStorage)
                const targetKeys = storageKeys.filter(key => 
                    key.includes('template') || 
                    key.includes('thumbnail') || 
                    key.includes('cache') || 
                    key.includes('supabase')
                )

                for (const key of targetKeys) {
                    try {
                        localStorage.removeItem(key)
                        log(`âœ… å·²æ¸…ç†localStorage: ${key}`, 'success')
                    } catch (error) {
                        errors.push(`localStorage.${key}: ${error.message}`)
                        log(`âš ï¸ localStorageæ¸…ç†å¤±è´¥: ${key}`, 'warning')
                    }
                }

                log('ğŸ‰ ç²¾å‡†åº”ç”¨ç¼“å­˜æ¸…ç†å®Œæˆï¼', 'success')
                log(`ğŸ“Š æ¸…ç†ç»Ÿè®¡ï¼šæ•°æ®åº“ ${clearedCount}ä¸ªï¼ŒlocalStorageé¡¹ ${targetKeys.length}ä¸ª`, 'info')
                
                if (errors.length > 0) {
                    log(`âš ï¸ éƒ¨åˆ†æ¸…ç†å¤±è´¥ï¼š${errors.length}ä¸ªé¡¹ç›®`, 'warning')
                    errors.forEach(err => log(`  - ${err}`, 'warning'))
                }
                
                log('ğŸ’¡ ç²¾å‡†æ¸…ç†å®Œæˆï¼Œåº”ç”¨ç¼“å­˜å·²æ›´æ–°', 'info')

            } catch (error) {
                log(`âŒ ç²¾å‡†æ¸…ç†è¿‡ç¨‹å‡ºé”™: ${error.message}`, 'error')
            }
        }
    </script>
</body>
</html>