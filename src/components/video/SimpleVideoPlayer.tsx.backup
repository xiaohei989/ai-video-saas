/**
 * SimpleVideoPlayer - 基于主流视频网站最佳实践的简化播放器
 * 
 * 设计理念：
 * - 使用原生 <video> 标签获得最佳性能
 * - preload="metadata" 实现快速启动
 * - 最小化 JavaScript 控制，依赖浏览器原生优化
 * - 对标 YouTube、Twitter 等主流网站的播放体验
 */

import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react'
import { Play, Pause, Volume2, VolumeX, Maximize, Minimize } from 'lucide-react'
import { cn } from '@/utils/cn'
import { getProxyVideoUrl, getVideoFallbackUrl } from '@/utils/videoUrlProxy'
import { getOptimalThumbnailSource, supportsMediaFragments } from '@/utils/thumbnailFallback'
import { ensurePreconnect, ensurePreloadVideo } from '@/utils/networkPriority'
import { 
  toggleFullscreen as toggleFullscreenHelper,
  getFullscreenState,
  detectDeviceCapabilities,
  bindVideoFullscreenEventsiOS,
  getFullscreenTooltip
} from '@/utils/fullscreenHelper'
import { useVideoPlayback, VideoPlayerInstance } from '@/contexts/VideoPlaybackContext'
import { useResponsiveDevice, supportsHover } from '@/utils/deviceDetection'

export interface SimpleVideoPlayerProps {
  // 基本属性
  src: string
  poster?: string
  className?: string
  alt?: string
  
  // 播放控制
  autoPlayOnHover?: boolean
  showPlayButton?: boolean
  muted?: boolean
  disablePreload?: boolean
  
  // 事件回调
  onPlay?: () => void
  onPause?: () => void
  onTimeUpdate?: (currentTime: number, duration: number, isPlaying: boolean) => void
  onLoadStart?: () => void
  onCanPlay?: () => void
  onError?: () => void
  onClick?: () => void
  // 新增：缓冲进度回调（用于外层自定义加载UI显示百分比）
  onBufferProgress?: (progress: number) => void
  
  // 样式控制
  objectFit?: 'contain' | 'cover'
  
  // 标识符（用于分析和调试）
  videoId?: string
  videoTitle?: string
  
  // URL回退（可选）
  fallbackSrc?: string
}

export default function SimpleVideoPlayer({
  src,
  poster,
  className,
  alt,
  autoPlayOnHover = false,
  showPlayButton = true,
  muted = false, // 默认有声音播放
  disablePreload = false,
  onPlay,
  onPause,
  onTimeUpdate,
  onLoadStart,
  onCanPlay,
  onError,
  onClick,
  onBufferProgress,
  objectFit = 'cover',
  videoId,
  videoTitle,
  fallbackSrc,
}: SimpleVideoPlayerProps) {
  const videoRef = useRef<HTMLVideoElement>(null)
  const containerRef = useRef<HTMLDivElement>(null)
  const [isPlaying, setIsPlaying] = useState(false)
  const [isHovered, setIsHovered] = useState(false)
  const [currentTime, setCurrentTime] = useState(0)
  const [duration, setDuration] = useState(0)
  const [showControls, setShowControls] = useState(false)
  const [isMuted, setIsMuted] = useState(muted)
  const [isFullscreen, setIsFullscreen] = useState(false)
  // 移除 isHoverLoading，统一使用 isBuffering 状态
  
  // 视频加载状态
  const [isLoading, setIsLoading] = useState(true)
  const [hasError, setHasError] = useState(false)
  const [hasMetadata, setHasMetadata] = useState(false)
  const [currentVideoSrc, setCurrentVideoSrc] = useState(src)
  const [hasTriedFallback, setHasTriedFallback] = useState(false)
  
  // 🚀 缓冲进度相关状态
  const [bufferProgress, setBufferProgress] = useState(0) // 原始进度
  const bufferProgressRef = useRef(0)
  const [uiProgress, setUiProgress] = useState(0) // 平滑显示进度
  const uiTargetRef = useRef(0)
  const progressAnimRef = useRef<number | null>(null)
  const heartbeatRef = useRef<number | null>(null)
  const lastRealUpdateRef = useRef<number>(0)
  const [isBuffering, setIsBuffering] = useState(false) // 是否正在缓冲
  const [canPlaySmooth, setCanPlaySmooth] = useState(false) // 是否有足够缓冲可以流畅播放
  const [currentPreload, setCurrentPreload] = useState<"none" | "metadata" | "auto">(disablePreload ? "none" : "metadata")
  
  // 🔧 修复点击暂停后自动播放的问题
  const [userPaused, setUserPaused] = useState(false) // 用户是否主动暂停
  // 用户是否在本播放器上产生过交互（用于移动端仅在交互后展示加载动画）
  const [hasInteracted, setHasInteracted] = useState(false)
  // 🔧 移动端专用：播放点击防抖，避免快速点击导致的播放/暂停循环
  const mobilePlayDebounceRef = useRef<number | null>(null)
  
  // 🔧 修复：组件挂载状态追踪，防止组件卸载后调用state setters
  const isMountedRef = useRef(true)

  // 🔍 调试：添加详细的错误日志系统
  const safeSetState = (setter: any, value: any, stateName: string) => {
    if (!isMountedRef.current) {
      return
    }
    
    if (typeof setter !== 'function') {
      console.error(`[SimpleVideoPlayer] ${stateName} setter不是函数:`, typeof setter, setter)
      return
    }
    
    try {
      setter(value)
    } catch (error) {
      console.error(`[SimpleVideoPlayer] 调用 ${stateName} setter时出错:`, error)
    }
  }
  
  // 悬停播放控制 - 简化版本
  
  // 设备能力检测 - 使用响应式检测
  const { isMobile, deviceType } = useResponsiveDevice()
  const [deviceCapabilities] = useState(detectDeviceCapabilities())
  const canHover = supportsHover() // 检测是否支持悬停
  // 悬停轻度抢占定时器（避免频繁 hover 即时打断）
  const hoverPreemptTimerRef = useRef<number | null>(null)
  // 悬停自动播放重试定时器
  const hoverRetryTimerRef = useRef<number | null>(null)

  // 🔧 修复：将playerId定义提前，避免在useCallback中引用未定义的变量
  // 简化的全局播放管理 - 仅用于点击播放控制
  const { registerPlayer, unregisterPlayer, requestPlay, notifyPause, isCurrentlyPlaying, isPendingPlay, immediateStopAll, isPlayMutexLocked } = useVideoPlayback()
  
  // 生成唯一的播放器ID
  const playerId = useMemo(() => {
    if (videoId) return videoId
    // 如果没有提供videoId，基于src生成唯一ID
    return `video-${src.split('/').pop()?.split('?')[0] || Math.random().toString(36).substr(2, 9)}`
  }, [videoId, src])

  // 进度动画：缓慢推进显示到目标值
  const ensureProgressAnimator = useCallback(() => {
    if (progressAnimRef.current) return
    progressAnimRef.current = window.setInterval(() => {
      // 🔧 修复：检查组件是否仍然挂载
      if (!isMountedRef.current) return
      
      const target = uiTargetRef.current
      safeSetState(setUiProgress, (prev: number) => {
        const diff = target - prev
        if (diff <= 0.05) return target
        const step = Math.min(Math.max(diff * 0.2, 0.5), 1.5) // 0.5%~1.5%
        const next = Math.min(prev + step, target)
        // 🔧 修复：使用 setTimeout 避免在 setState 回调中直接调用父组件的回调
        setTimeout(() => {
          if (isMountedRef.current) {
            onBufferProgress?.(next)
          }
        }, 0)
        return next
      }, 'uiProgress')
    }, 66)
  }, [onBufferProgress, safeSetState])

  const stopProgressAnimator = useCallback(() => {
    if (progressAnimRef.current) {
      clearInterval(progressAnimRef.current)
      progressAnimRef.current = null
    }
  }, [])

  const setUiTarget = useCallback((value: number) => {
    const clamped = Math.max(0, Math.min(100, value))
    uiTargetRef.current = Math.max(uiTargetRef.current, clamped)
    // 🔧 修复：使用 setTimeout 避免在渲染期间直接启动动画
    setTimeout(() => ensureProgressAnimator(), 0)
  }, [ensureProgressAnimator])

  // 心跳推进，缺少真实进度时缓慢到65%
  const startHeartbeat = useCallback(() => {
    if (heartbeatRef.current) return
    console.log(`[SimpleVideoPlayer] 开始心跳进度更新: ${playerId}`)
    heartbeatRef.current = window.setInterval(() => {
      // 🔧 修复：检查组件是否仍然挂载
      if (!isMountedRef.current) return
      
      const now = Date.now()
      // 🔧 修复：移除65%硬编码限制，允许进度正常更新到95%
      // 最后5%保留给真实的播放事件更新，避免显示100%但实际未完成
      if (now - lastRealUpdateRef.current > 600 && uiTargetRef.current < 95) {
        // 🚀 优化：根据当前进度调整增长速度
        const currentProgress = uiTargetRef.current
        let increment = 1
        
        // 0-30%: 正常速度
        if (currentProgress < 30) {
          increment = 1
        }
        // 30-60%: 稍慢
        else if (currentProgress < 60) {
          increment = 0.8
        }
        // 60-80%: 更慢
        else if (currentProgress < 80) {
          increment = 0.5
        }
        // 80-95%: 最慢，给真实加载更多时间
        else {
          increment = 0.2
        }
        
        const newProgress = Math.min(95, uiTargetRef.current + increment)
        
        // 移动端：在关键进度点记录日志
        if (isMobile && (newProgress >= 65 && currentProgress < 65)) {
          console.log(`[SimpleVideoPlayer-Mobile] 突破65%进度限制: ${playerId}, 新进度: ${newProgress}%`)
        }
        
        safeSetState(setUiTarget, newProgress, 'uiTarget')
      }
    }, 400)
  }, [setUiTarget, playerId, isMobile])

  const stopHeartbeat = useCallback(() => {
    if (heartbeatRef.current) {
      clearInterval(heartbeatRef.current)
      heartbeatRef.current = null
    }
  }, [])

  // 原始进度记录 + 设置显示目标（单调递增）
  const setProgressMonotonic = useCallback((value: number) => {
    // 🔧 修复：检查组件是否仍然挂载
    if (!isMountedRef.current) return
    
    const clamped = Math.max(0, Math.min(100, value))
    safeSetState(setBufferProgress, (prev: number) => {
      const next = Math.max(prev, clamped)
      bufferProgressRef.current = next
      return next
    }, 'bufferProgress')
    lastRealUpdateRef.current = Date.now()
    safeSetState(setUiTarget, clamped, 'uiTarget')
  }, [setUiTarget])

  // 简化的视频源优化 - 不再区分悬停模式
  const getOptimizedVideoUrl = (videoSrc: string): string => {
    const proxyUrl = getProxyVideoUrl(videoSrc)
    // 为提升兼容性，统一移除 Media Fragments（#t=...）
    return proxyUrl
  }

  // 智能缩略图源选择
  const optimalPoster = getOptimalThumbnailSource(src, poster)

  // 🚀 优化：当有缩略图时，立即允许显示内容，无需等待视频加载
  useEffect(() => {
    if (optimalPoster && isLoading) {
      // 如果有可用的缩略图，可以立即显示内容，无需等待视频元数据
      // 🔧 修复：移除 isLoading 依赖，避免渲染期间 setState 循环
      safeSetState(setIsLoading, false, 'isLoading')
    }
  }, [optimalPoster, playerId]) // 移除 isLoading 依赖

  // 创建播放器实例接口
  const playerInstance = useMemo<VideoPlayerInstance>(() => ({
    id: playerId,
    pause: () => {
      const video = videoRef.current
      if (video && !video.paused) {
        video.pause()
      }
    },
    play: async () => {
      const video = videoRef.current
      if (video && (video.paused || video.ended)) {
        // 🔧 关键修复：如果视频已结束，重置到开始位置
        if (video.ended) {
          video.currentTime = 0
        }
        await video.play()
      }
    },
    getCurrentTime: () => videoRef.current?.currentTime || 0,
    getDuration: () => videoRef.current?.duration || 0,
    isPlaying: () => !!(videoRef.current && !videoRef.current.paused && !videoRef.current.ended),
    // 立即停止方法：暂停并重置到开始位置
    stopImmediate: () => {
      const video = videoRef.current
      if (video) {
        if (!video.paused) {
          video.pause()
        }
        video.currentTime = 0
      }
    }
  }), [playerId])

  // 注册和注销播放器
  useEffect(() => {
    // 🔧 修复：安全调用registerPlayer，防止context被销毁时调用失败
    if (typeof registerPlayer === 'function') {
      registerPlayer(playerId, playerInstance)
    }
    
    return () => {
      // 🔧 修复：安全调用unregisterPlayer，防止context被销毁时调用失败
      if (typeof unregisterPlayer === 'function') {
        unregisterPlayer(playerId)
      }
    }
  }, [playerId, registerPlayer, unregisterPlayer])

  // 处理src变化，重置回退状态和缓冲状态
  useEffect(() => {
    if (src !== currentVideoSrc) {
      safeSetState(setCurrentVideoSrc, src, 'currentVideoSrc')
      safeSetState(setHasTriedFallback, false, 'hasTriedFallback')
      safeSetState(setHasError, false, 'hasError')
      safeSetState(setIsLoading, true, 'isLoading')
      // 🔄 只在视频源改变时才重置缓冲状态
      safeSetState(setBufferProgress, 0, 'bufferProgress')
      bufferProgressRef.current = 0
      safeSetState(setUiProgress, 0, 'uiProgress')
      uiTargetRef.current = 0
      safeSetState(setCanPlaySmooth, false, 'canPlaySmooth')
      safeSetState(setIsBuffering, false, 'isBuffering')
      safeSetState(setCurrentPreload, disablePreload ? "none" : "metadata", 'currentPreload')
    }
  }, [src])

  // 基于悬停尝试自动播放（可重试）
  const attemptHoverAutoplay = useCallback((enableRetry: boolean = false) => {
    const video = videoRef.current
    if (!video) return
    if (!(autoPlayOnHover && isHovered && !userPaused)) return
    if (isCurrentlyPlaying(playerId) || !video.paused) return
    // 保持当前静音状态，不再强制静音以满足自动播放策略
    // 若互斥锁被占用，优先释放（悬浮自动播放优先当前视频）
    try {
      // 🔧 修复：安全调用isPlayMutexLocked和immediateStopAll，防止context被销毁时调用失败
      if (typeof isPlayMutexLocked === 'function' && isPlayMutexLocked()) {
        if (typeof immediateStopAll === 'function') {
          immediateStopAll()
        }
      }
    } catch {}
    // 🔧 修复：安全调用requestPlay，防止context被销毁时调用失败
    const ok = typeof requestPlay === 'function' ? requestPlay(playerId) : false
    if (ok) {
      video.play().catch(() => {})
    } else if (enableRetry) {
      if (hoverRetryTimerRef.current) window.clearTimeout(hoverRetryTimerRef.current)
      hoverRetryTimerRef.current = window.setTimeout(() => {
        try {
          // 🔧 修复：安全调用isPlayMutexLocked和immediateStopAll，防止context被销毁时调用失败
          if (typeof isPlayMutexLocked === 'function' && isPlayMutexLocked()) {
            if (typeof immediateStopAll === 'function') {
              immediateStopAll()
            }
          }
        } catch {}
        // 🔧 修复：安全调用requestPlay，防止context被销毁时调用失败
        const ok2 = typeof requestPlay === 'function' ? requestPlay(playerId) : false
        if (ok2) {
          video.play().catch(() => {})
        }
      }, 120)
    }
  }, [autoPlayOnHover, isHovered, userPaused, isCurrentlyPlaying, playerId, isMuted, requestPlay, isPlayMutexLocked, immediateStopAll])

  // 处理播放状态变化
  useEffect(() => {
    const video = videoRef.current
    if (!video) return

    const handlePlay = () => {
      safeSetState(setIsPlaying, true, 'isPlaying')
      safeSetState(setIsBuffering, false, 'isBuffering') // 播放开始时取消缓冲状态
      safeSetState(setIsLoading, false, 'isLoading') // 🔧 修复：视频开始播放时立即取消加载状态，避免骨骼屏遮挡画面
      safeSetState(setUiTarget, 100, 'uiTarget')
      stopHeartbeat()
      onPlay?.()
    }

    const handlePause = () => {
      safeSetState(setIsPlaying, false, 'isPlaying')
      // 🔧 修复：安全调用notifyPause，防止context被销毁时调用失败
      if (typeof notifyPause === 'function') {
        notifyPause(playerId)
      }
      onPause?.()
    }

    const handleTimeUpdate = () => {
      const time = video.currentTime
      const dur = video.duration || 0
      safeSetState(setCurrentTime, time, 'currentTime')
      onTimeUpdate?.(time, dur, !video.paused)
    }

    const handleLoadedMetadata = () => {
      safeSetState(setDuration, video.duration || 0, 'duration')
      safeSetState(setHasMetadata, true, 'hasMetadata')
      safeSetState(setIsLoading, false, 'isLoading')
      // 元数据已就绪，给出保守的进度反馈，避免长时间显示0%
      safeSetState(setProgressMonotonic, 10, 'progressMonotonic')
      safeSetState(setUiTarget, 15, 'uiTarget')
    }

    const handleEnded = () => {
      safeSetState(setIsPlaying, false, 'isPlaying')
      // 🔧 关键修复：视频结束后总是重置到开始位置，确保可以重新播放
      video.currentTime = 0
      // 🔧 修复：安全调用notifyPause，防止context被销毁时调用失败
      if (typeof notifyPause === 'function') {
        notifyPause(playerId)
      }
    }

    // 加载状态处理
    const handleLoadStart = () => {
      safeSetState(setIsLoading, true, 'isLoading')
      safeSetState(setHasError, false, 'hasError')
      // 🔧 移动端优化：简化缓冲判断逻辑，避免复杂的交互状态依赖
      const shouldBuffer = isMobile ? 
        hasInteracted : // 移动端：仅在用户交互后显示缓冲
        (autoPlayOnHover && isHovered) || hasInteracted // 桌面端：保持原有逻辑
      
      safeSetState(setIsBuffering, shouldBuffer, 'isBuffering')
      // 加载开始时给一个最小进度，避免显示为0%
      safeSetState(setProgressMonotonic, 1, 'progressMonotonic')
      safeSetState(setUiTarget, 5, 'uiTarget')
      if (shouldBuffer) startHeartbeat()
      onLoadStart?.()
    }

    const handleLoadedData = () => {
      safeSetState(setIsLoading, false, 'isLoading')
      // 已有当前帧数据，进度至少提升到25%
      safeSetState(setProgressMonotonic, 25, 'progressMonotonic')
      safeSetState(setUiTarget, 30, 'uiTarget')
    }

    const handleError = () => {
      
      // 使用智能回退机制
      if (!hasTriedFallback) {
        const fallbackUrl = getVideoFallbackUrl(currentVideoSrc, src)
        
        if (fallbackUrl !== currentVideoSrc) {
          
          safeSetState(setHasTriedFallback, true, 'hasTriedFallback')
          safeSetState(setCurrentVideoSrc, fallbackUrl, 'currentVideoSrc')
          safeSetState(setIsLoading, true, 'isLoading')
          safeSetState(setHasError, false, 'hasError')
          
          // 更新video元素的src
          if (video) {
            video.src = fallbackUrl
            video.load()
          }
          return
        }
      }
      
      // 如果还有用户提供的回退URL且还未尝试过，则尝试回退
      if (fallbackSrc && currentVideoSrc !== fallbackSrc && !currentVideoSrc.includes(fallbackSrc)) {
        
        safeSetState(setCurrentVideoSrc, fallbackSrc, 'currentVideoSrc')
        safeSetState(setIsLoading, true, 'isLoading')
        safeSetState(setHasError, false, 'hasError')
        
        // 更新video元素的src
        if (video) {
          video.src = getOptimizedVideoUrl(fallbackSrc)
          video.load()
        }
        return
      }
      
      // 所有回退策略都失败了，显示错误
      safeSetState(setIsLoading, false, 'isLoading')
      safeSetState(setHasError, true, 'hasError')
      onError?.()
    }

    const handleCanPlay = () => {
      safeSetState(setIsLoading, false, 'isLoading')
      safeSetState(setIsBuffering, false, 'isBuffering') // 视频可以播放时取消缓冲状态
      safeSetState(setCanPlaySmooth, true, 'canPlaySmooth') // 标记可以流畅播放
      // 可播放时，提升到至少60%
      safeSetState(setProgressMonotonic, 60, 'progressMonotonic')
      safeSetState(setUiTarget, 65, 'uiTarget')
      // 尝试悬停自动播放（必要时重试）
      attemptHoverAutoplay(true)
      
      onCanPlay?.()
    }

    // 🚀 缓冲进度监听器
    const handleProgress = () => {
      // 当还没有buffer信息时，采用就绪态近似进度，避免卡在0%
      if (!video.buffered.length) {
        // 根据readyState给近似百分比
        const approx = video.readyState >= 4 ? 90 : video.readyState >= 3 ? 60 : video.readyState >= 2 ? 25 : 10
        safeSetState(setProgressMonotonic, approx, 'progressMonotonic')
        safeSetState(setUiTarget, Math.max(uiTargetRef.current, approx), 'uiTarget')
        return
      }
      
      const duration = video.duration
      if (!duration || !isFinite(duration) || duration <= 0) {
        // 未知时长时采用近似百分比
        const approx = video.readyState >= 4 ? 90 : video.readyState >= 3 ? 60 : video.readyState >= 2 ? 25 : 10
        safeSetState(setProgressMonotonic, approx, 'progressMonotonic')
        safeSetState(setUiTarget, Math.max(uiTargetRef.current, approx), 'uiTarget')
        return
      }
      
      // 计算已缓冲的最大时间点
      let bufferedEnd = 0
      for (let i = 0; i < video.buffered.length; i++) {
        bufferedEnd = Math.max(bufferedEnd, video.buffered.end(i))
      }
      
      // 计算缓冲进度百分比
      const progress = (bufferedEnd / duration) * 100
      safeSetState(setProgressMonotonic, progress, 'progressMonotonic')
      safeSetState(setUiTarget, Math.max(uiTargetRef.current, progress), 'uiTarget')
      
      // 判断是否有足够缓冲可以开始播放（至少3秒或10%）
      const bufferedSeconds = bufferedEnd - video.currentTime
      const hasEnoughBuffer = bufferedSeconds >= 3 || progress >= 10
      safeSetState(setCanPlaySmooth, hasEnoughBuffer, 'canPlaySmooth')
      
      // 🚀 简化缓冲逻辑：当缓冲足够时尝试自动开始播放
      if (hasEnoughBuffer && isBuffering && autoPlayOnHover && isHovered && !userPaused) {
        
        // 🔧 延迟隐藏缓冲状态，确保用户能看到100%
        if (progress >= 99) {
          setTimeout(() => {
            // 🔧 修复：检查组件是否仍然挂载
            if (!isMountedRef.current) return
            safeSetState(setIsBuffering, false, 'isBuffering')
          }, 300) // 延迟300ms隐藏
        } else {
          // 🔧 修复：检查组件是否仍然挂载
          if (!isMountedRef.current) return
          safeSetState(setIsBuffering, false, 'isBuffering')
        }
        // 尝试悬停自动播放（必要时重试）
        attemptHoverAutoplay(true)
      } else if (hasEnoughBuffer && isBuffering && userPaused && isHovered) {
        // 即使用户暂停了，也要隐藏缓冲状态
        safeSetState(setIsBuffering, false, 'isBuffering')
      }
      
    }

    // 🚀 缓冲状态监听器
    const handleWaiting = () => {
      const shouldBuffer = (autoPlayOnHover && isHovered) || hasInteracted
      safeSetState(setIsBuffering, shouldBuffer, 'isBuffering')
      // 等待缓冲时，根据readyState设置一个保底进度，避免停在0%
      const approx = video.readyState >= 3 ? 60 : video.readyState >= 2 ? 25 : 10
      safeSetState(setProgressMonotonic, approx, 'progressMonotonic')
      safeSetState(setUiTarget, Math.max(uiTargetRef.current, approx), 'uiTarget')
    }

    const handleCanPlayThrough = () => {
      safeSetState(setIsBuffering, false, 'isBuffering')
      safeSetState(setCanPlaySmooth, true, 'canPlaySmooth')
      // 足以流畅播放，进度提升到90%
      safeSetState(setProgressMonotonic, 90, 'progressMonotonic')
      safeSetState(setUiTarget, 90, 'uiTarget')
      stopHeartbeat()
      // 再次尝试悬浮自动播放（防止错过 canplay）
      attemptHoverAutoplay(true)
    }

    video.addEventListener('play', handlePlay)
    video.addEventListener('pause', handlePause)
    video.addEventListener('timeupdate', handleTimeUpdate)
    video.addEventListener('loadedmetadata', handleLoadedMetadata)
    video.addEventListener('ended', handleEnded)
    video.addEventListener('loadstart', handleLoadStart)
    video.addEventListener('loadeddata', handleLoadedData)
    video.addEventListener('error', handleError)
    video.addEventListener('canplay', handleCanPlay)
    video.addEventListener('progress', handleProgress)
    video.addEventListener('waiting', handleWaiting)
    video.addEventListener('canplaythrough', handleCanPlayThrough)

    return () => {
      video.removeEventListener('play', handlePlay)
      video.removeEventListener('pause', handlePause)
      video.removeEventListener('timeupdate', handleTimeUpdate)
      video.removeEventListener('loadedmetadata', handleLoadedMetadata)
      video.removeEventListener('ended', handleEnded)
      video.removeEventListener('loadstart', handleLoadStart)
      video.removeEventListener('loadeddata', handleLoadedData)
      video.removeEventListener('error', handleError)
      video.removeEventListener('canplay', handleCanPlay)
      video.removeEventListener('progress', handleProgress)
      video.removeEventListener('waiting', handleWaiting)
      video.removeEventListener('canplaythrough', handleCanPlayThrough)
    }
  }, [onPlay, onPause, onTimeUpdate, onLoadStart, onCanPlay, onError, currentVideoSrc, hasTriedFallback, fallbackSrc, playerId, notifyPause, isBuffering, autoPlayOnHover, isHovered, isCurrentlyPlaying, requestPlay, userPaused, attemptHoverAutoplay])

  // 🚀 添加加载超时机制，防止 isLoading 状态永久卡住
  useEffect(() => {
    if (!isLoading || disablePreload) return

    const timeout = setTimeout(() => {
      // 🔧 修复：检查组件是否仍然挂载
      if (!isMountedRef.current) return
      
      const video = videoRef.current
      if (video && isLoading) {
        safeSetState(setIsLoading, false, 'isLoading')
      }
    }, 3000) // 3秒超时

    return () => clearTimeout(timeout)
  }, [isLoading, playerId, disablePreload])

  // 🚀 添加状态一致性检查，检测并修正状态不一致的情况
  useEffect(() => {
    const video = videoRef.current
    if (!video || disablePreload) return

    // 定期检查状态一致性
    const checkInterval = setInterval(() => {
      // 检测1：视频已准备好但仍显示加载状态
      if (isLoading && video.readyState >= 1) {
        safeSetState(setIsLoading, false, 'isLoading')
        safeSetState(setHasMetadata, true, 'hasMetadata')
      }

      // 检测2：视频有duration但hasMetadata为false
      if (!hasMetadata && video.duration && video.duration > 0) {
        safeSetState(setHasMetadata, true, 'hasMetadata')
        safeSetState(setDuration, video.duration, 'duration')
      }
    }, 1000) // 每秒检查一次

    return () => clearInterval(checkInterval)
  }, [playerId, disablePreload]) // 🔧 修复：移除状态依赖，避免循环

  // 🚀 组件挂载后立即进行一次状态检查
  useEffect(() => {
    const video = videoRef.current
    if (!video || disablePreload) return

    // 短暂延迟后检查初始状态，确保 video 元素已经开始加载
    const initialCheck = setTimeout(() => {
      // 🔧 修复：检查组件是否仍然挂载
      if (!isMountedRef.current) return
      
      // 如果视频已经有poster或背景图，但仍在loading状态，可能需要重置
      if (isLoading && (optimalPoster || video.poster)) {
        // 检查视频是否实际需要加载状态
        if (video.readyState === 0 && video.networkState === video.NETWORK_NO_SOURCE) {
          // 视频还没开始加载，这是正常的
        } else if (video.readyState >= 1) {
          // 视频已经有元数据了，重置加载状态
          // 🔧 修复：检查组件是否仍然挂载（双重检查）
          if (!isMountedRef.current) return
          safeSetState(setIsLoading, false, 'isLoading')
        }
      }
    }, 100)

    return () => clearTimeout(initialCheck)
  }, [disablePreload]) // 只在挂载时执行一次

  // 🎯 简化悬停播放控制 - 根据用户要求完全重写
  const handleMouseEnter = useCallback(() => {
    // 移动端或不支持悬停的设备不触发鼠标悬停逻辑
    if (isMobile || !canHover) {
      return
    }

    safeSetState(setIsHovered, true, 'isHovered')
    safeSetState(setShowControls, true, 'showControls')
    
    const video = videoRef.current
    if (!autoPlayOnHover || !video) return
    
    
    // 🔧 如果用户主动暂停了，不自动播放
    if (userPaused) {
      return
    }
    
    // 🚀 简化逻辑：检查视频是否可以播放
    if (video.readyState >= 3) {
      // 🔧 修复：安全调用requestPlay，防止context被销毁时调用失败
      const success = typeof requestPlay === 'function' ? requestPlay(playerId) : false
      if (success) {
        video.play().catch(() => {})
      }
    } else {
      // 视频还在加载 - 显示加载动画
      safeSetState(setIsBuffering, true, 'isBuffering')
      
      // 启用预加载加速缓冲
      if (currentPreload !== "auto") {
        safeSetState(setCurrentPreload, "auto", 'currentPreload')
        video.preload = "auto"
        // 优先网络：预连接 + rel=preload 提升当前视频优先级
        try {
          const prioritizedUrl = getOptimizedVideoUrl(currentVideoSrc)
          ensurePreconnect(prioritizedUrl)
          ensurePreloadVideo(prioritizedUrl)
        } catch {}
        video.load()
      }
      // 悬停轻度抢占：短延迟后若仍需缓冲且互斥锁被占用，则释放锁以优先当前交互视频
      if (hoverPreemptTimerRef.current) {
        clearTimeout(hoverPreemptTimerRef.current)
      }
      hoverPreemptTimerRef.current = window.setTimeout(() => {
        if (isHovered && autoPlayOnHover && isBuffering && !userPaused && typeof isPlayMutexLocked === 'function' && isPlayMutexLocked()) {
          try { 
            // 🔧 修复：安全调用immediateStopAll，防止context被销毁时调用失败
            if (typeof immediateStopAll === 'function') {
              immediateStopAll()
            }
          } catch {}
          // 锁释放后尝试一次自动播放
          attemptHoverAutoplay(true)
        }
      }, 250)
    }
  }, [autoPlayOnHover, currentPreload, isMobile, playerId, requestPlay, userPaused, isHovered, isBuffering, isPlayMutexLocked, currentVideoSrc, immediateStopAll, attemptHoverAutoplay])

  const handleMouseLeave = useCallback(() => {
    if (isMobile || !canHover) {
      return
    }

    // 🔧 修复：检查组件是否仍然挂载
    if (!isMountedRef.current) return
    
    safeSetState(setIsHovered, false, 'isHovered')
    safeSetState(setShowControls, false, 'showControls')
    
    const video = videoRef.current
    if (!autoPlayOnHover || !video) return
    
    
    // 🛑 修复悬停离开逻辑：区分用户主动暂停和悬停离开
    if (!video.paused) {
      video.pause()
      // 只有在悬停自动播放模式下才重置位置
      // 如果用户主动暂停过，保持当前位置
      if (!userPaused) {
        video.currentTime = 0  // 重置到开始位置
      }
      // 🔧 修复：再次检查组件挂载状态
      if (isMountedRef.current) {
        safeSetState(setIsPlaying, false, 'isPlaying')
      }
      // 🔧 修复：安全调用notifyPause，防止context被销毁时调用失败
      if (typeof notifyPause === 'function') {
        notifyPause(playerId)
      }
    }
    
    // 隐藏所有UI组件
    if (isMountedRef.current) {
      safeSetState(setIsBuffering, false, 'isBuffering')
    }
    
    // 🔧 重置用户暂停状态，下次鼠标进入时可以重新自动播放
    safeSetState(setUserPaused, false, 'userPaused')
    // 清理悬停轻度抢占计时器
    if (hoverPreemptTimerRef.current) {
      clearTimeout(hoverPreemptTimerRef.current)
      hoverPreemptTimerRef.current = null
    }
    // 清理悬停自动播放重试
    if (hoverRetryTimerRef.current) {
      clearTimeout(hoverRetryTimerRef.current)
      hoverRetryTimerRef.current = null
    }
    
  }, [autoPlayOnHover, isMobile, playerId, notifyPause])

  // 🎯 修复点击播放/暂停 - 确保播放状态与UI同步
  const handlePlayPause = useCallback(async (e?: React.MouseEvent) => {
    e?.stopPropagation()
    
    const video = videoRef.current
    if (!video) return

    // 🔧 移动端防抖优化：增加防抖时间到250ms，确保触摸事件稳定
    if (isMobile) {
      if (mobilePlayDebounceRef.current) {
        clearTimeout(mobilePlayDebounceRef.current)
      }
      // 防抖时间增加到250ms，避免移动端快速触摸导致的状态混乱
      const now = Date.now()
      const lastClickTime = (video as any).__lastClickTime || 0
      if (now - lastClickTime < 250) {
        console.log('[SimpleVideoPlayer] 移动端防抖：忽略快速点击')
        return
      }
      (video as any).__lastClickTime = now
      
      // 🚀 添加触摸状态跟踪，避免同时处理touch和click事件
      if ((video as any).__touchInProgress) {
        console.log('[SimpleVideoPlayer] 触摸事件进行中，跳过click处理')
        return
      }
    }

    // 移动端点击时立即显示控制层，避免用户没有反馈
    safeSetState(setShowControls, true, 'showControls')
    safeSetState(setHasInteracted, true, 'hasInteracted')

    // 🔧 移动端修复：使用video元素的实际播放状态而不是全局状态，避免状态同步延迟
    const isActuallyPlaying = !video.paused && !video.ended
    const isCurrentlyPlayingNow = isCurrentlyPlaying(playerId)

    if (isActuallyPlaying || isCurrentlyPlayingNow) {
      // 🔧 移动端调试日志
      if (isMobile) {
        console.log(`[SimpleVideoPlayer-Mobile] 暂停播放: ${playerId}, 当前时间: ${video.currentTime.toFixed(2)}s`)
      }
      
      // 当前播放中，直接暂停
      video.pause()
      // 🔧 修复点击暂停问题：用户主动点击暂停时不重置位置，保持当前播放进度
      // 只有在悬停离开时才重置位置（在 handleMouseLeave 中处理）
      // 🔧 修复：安全调用notifyPause，防止context被销毁时调用失败
      if (typeof notifyPause === 'function') {
        notifyPause(playerId)
      }
      
      // 🔧 关键修复：设置用户暂停标记，防止悬停时自动播放
      safeSetState(setUserPaused, true, 'userPaused')
    } else {
      // 🔧 修复：等待播放请求完成后再更新UI状态
      try {
        // 先检查是否可以播放
        if (!video.src || video.networkState === video.NETWORK_NO_SOURCE) {
          return
        }

        // 移动端点击：无条件开启完整预加载，并在未就绪时主动触发加载
        if (isMobile) {
          console.log(`[SimpleVideoPlayer-Mobile] 开始播放准备: ${playerId}`)
          console.log(`[SimpleVideoPlayer-Mobile] 视频就绪状态: ${video.readyState}, 网络状态: ${video.networkState}`)
          console.log(`[SimpleVideoPlayer-Mobile] 缓冲进度: ${bufferProgress}%, UI进度: ${uiProgress}%`)
          
          if (currentPreload !== "auto") safeSetState(setCurrentPreload, "auto", 'currentPreload')
          video.preload = "auto"
          if (video.readyState < 3) {
            safeSetState(setIsBuffering, true, 'isBuffering')
            console.log(`[SimpleVideoPlayer-Mobile] 触发缓冲状态，readyState: ${video.readyState}`)
            // 提升网络优先级
            try {
              const prioritizedUrl = getOptimizedVideoUrl(currentVideoSrc)
              ensurePreconnect(prioritizedUrl)
              ensurePreloadVideo(prioritizedUrl)
            } catch {}
            try {
              video.load()
            } catch {}
          }
        }

        // 🔧 用户主动播放时，清除暂停标记
        safeSetState(setUserPaused, false, 'userPaused')

        // 🔧 关键修复：先请求播放权限，让全局管理器处理其他视频的停止
        // 移除 immediateStopAll() 调用，避免停止当前正在播放的视频
        
        // 提升网络优先级：预连接 + rel=preload
        try {
          const prioritizedUrl = getOptimizedVideoUrl(currentVideoSrc)
          ensurePreconnect(prioritizedUrl)
          ensurePreloadVideo(prioritizedUrl)
        } catch {}

        // 🔧 修复：安全调用requestPlay，防止context被销毁时调用失败
        const success = typeof requestPlay === 'function' ? requestPlay(playerId) : false
        // 🔧 移动端修复：如果全局管理器拒绝播放请求，短延迟后重试
        if (!success) {
          // 短延迟后重试，让全局管理器有时间处理状态更新
          setTimeout(() => {
            // 🔧 修复：检查组件是否仍然挂载
            if (!isMountedRef.current) return
            
            // 🔧 修复：安全调用requestPlay，防止context被销毁时调用失败
            const retrySuccess = typeof requestPlay === 'function' ? requestPlay(playerId) : false
            if (retrySuccess) {
              video.play().catch(() => {})
            }
          }, 50)
        }

        // 📱 桌面/移动统一：点击后确保进入预加载并在当前手势内调用 play
        // 预加载：不足可播数据时，切换为 auto 并触发 load
        if (currentPreload !== "auto") safeSetState(setCurrentPreload, "auto", 'currentPreload')
        video.preload = "auto"
        if (video.readyState < 2) {
          safeSetState(setIsBuffering, true, 'isBuffering')
          try {
            const prioritizedUrl = getOptimizedVideoUrl(currentVideoSrc)
            ensurePreconnect(prioritizedUrl)
            ensurePreloadVideo(prioritizedUrl)
          } catch {}
          try { video.load() } catch {}
        }

        // 🔧 关键修复：移动端播放前重置视频到开始位置
        // 让全局管理器完全控制播放，避免状态不同步
        if (video.ended) {
          video.currentTime = 0
        }
        
        // 🔧 移动端修复：播放状态完全由全局管理器控制
        // 移除手动播放调用，避免与全局管理器的播放逻辑冲突
      } catch (error) {
        // 🔧 修复：安全调用notifyPause，防止context被销毁时调用失败
        if (typeof notifyPause === 'function') {
          notifyPause(playerId)
        }
      }
    }
  }, [
    playerId,
    currentPreload,
    isMobile,
    isCurrentlyPlaying,
    notifyPause,
    requestPlay
  ])

  // 点击视频区域播放/暂停
  const handleVideoClick = (e: React.MouseEvent) => {
    e.preventDefault()
    onClick?.()
    handlePlayPause(e)
  }

  // 静音切换
  const handleMuteToggle = (e: React.MouseEvent) => {
    e.stopPropagation()
    
    const video = videoRef.current
    if (!video) return
    
    const newMuted = !isMuted
    video.muted = newMuted
    safeSetState(setIsMuted, newMuted, 'isMuted')
  }

  // 进度条点击跳转
  const handleProgressClick = (e: React.MouseEvent) => {
    e.stopPropagation()
    
    const video = videoRef.current
    if (!video || !duration) return

    const rect = e.currentTarget.getBoundingClientRect()
    const clickX = e.clientX - rect.left
    const clickRatio = clickX / rect.width
    const newTime = clickRatio * duration
    
    video.currentTime = newTime
    safeSetState(setCurrentTime, newTime, 'currentTime')
  }

  // 全屏切换功能 - iOS兼容版本
  const toggleFullscreen = async () => {
    const video = videoRef.current
    const container = containerRef.current
    
    if (!video) {
      return
    }

    try {
      const success = await toggleFullscreenHelper(video, container || undefined)
      if (!success) {
        // iOS设备的回退方案
        if (deviceCapabilities.isiOS) {
          // iOS用户可以使用原生视频控制条进入全屏
        }
      }
    } catch (error) {
    }
  }

  // iOS全屏事件监听
  useEffect(() => {
    const video = videoRef.current
    if (!video || !deviceCapabilities.isiOS) return

    const cleanup = bindVideoFullscreenEventsiOS(
      video,
      () => {
        safeSetState(setIsFullscreen, true, 'isFullscreen')
      },
      () => {
        safeSetState(setIsFullscreen, false, 'isFullscreen')
      }
    )

    return cleanup
  }, [deviceCapabilities.isiOS])

  // 标准全屏事件监听（非iOS）
  useEffect(() => {
    if (deviceCapabilities.isiOS) return

    const handleFullscreenChange = () => {
      const state = getFullscreenState()
      safeSetState(setIsFullscreen, state.isFullscreen, 'isFullscreen')
    }

    document.addEventListener('fullscreenchange', handleFullscreenChange)
    return () => {
      document.removeEventListener('fullscreenchange', handleFullscreenChange)
    }
  }, [deviceCapabilities.isiOS])

  // 🔧 强化组件卸载清理：确保所有资源被彻底清理
  useEffect(() => {
    return () => {
      console.log(`[SimpleVideoPlayer] 清理播放器资源: ${playerId}`)
      
      // 🔧 修复：标记组件已卸载，防止后续state setter调用
      isMountedRef.current = false
      
      // 清理所有定时器
      if (hoverPreemptTimerRef.current) {
        clearTimeout(hoverPreemptTimerRef.current)
        hoverPreemptTimerRef.current = null
      }
      if (hoverRetryTimerRef.current) {
        clearTimeout(hoverRetryTimerRef.current)
        hoverRetryTimerRef.current = null
      }
      if (progressAnimRef.current) {
        clearInterval(progressAnimRef.current)
        progressAnimRef.current = null
      }
      if (heartbeatRef.current) {
        clearInterval(heartbeatRef.current)
        heartbeatRef.current = null
      }
      if (mobilePlayDebounceRef.current) {
        clearTimeout(mobilePlayDebounceRef.current)
        mobilePlayDebounceRef.current = null
      }
      
      // 🚀 移动端专用：清理触摸状态和视频元素状态
      const video = videoRef.current
      if (video && isMobile) {
        (video as any).__touchInProgress = false
        (video as any).__lastClickTime = 0
        console.log(`[SimpleVideoPlayer] 清理移动端视频状态: ${playerId}`)
      }
      
      // 🔧 强制释放全局播放锁，防止卡住状态影响其他视频
      try {
        if (typeof isCurrentlyPlaying === 'function' && isCurrentlyPlaying(playerId)) {
          // 🔧 修复：安全调用notifyPause，防止context被销毁时调用失败
          if (typeof notifyPause === 'function') {
            notifyPause(playerId)
            console.log(`[SimpleVideoPlayer] 强制释放播放状态: ${playerId}`)
          }
        }
      } catch (error) {
        console.warn(`[SimpleVideoPlayer] 清理播放状态失败: ${playerId}`, error)
      }
      
      // 🔧 修复：组件卸载时不调用state setters，避免"false is not a function"错误
      // 只清理ref值，不设置state
      uiTargetRef.current = 0
      bufferProgressRef.current = 0
      
      console.log(`[SimpleVideoPlayer] 资源清理完成: ${playerId}`)
    }
  }, [playerId, isCurrentlyPlaying, notifyPause, isMobile])

  // 格式化时间显示
  const formatTime = (seconds: number) => {
    if (!isFinite(seconds)) return '0:00'
    const mins = Math.floor(seconds / 60)
    const secs = Math.floor(seconds % 60)
    return `${mins}:${secs.toString().padStart(2, '0')}`
  }


  return (
    <div 
      ref={containerRef}
      className={cn("relative group bg-muted overflow-hidden", className)}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
    >

      {/* 原生视频元素 */}
      <video
        ref={videoRef}
        src={getOptimizedVideoUrl(currentVideoSrc)}
        poster={optimalPoster}
        className={cn(
          `w-full h-full cursor-pointer`,
          objectFit === 'cover' ? 'object-cover' : 'object-contain',
          // 🚀 修复：移除 opacity-0，改用更精确的状态控制
          // 让 CSS 背景图始终可见，只在真正错误时才完全隐藏
          hasError && !optimalPoster ? 'hidden' : ''
        )}
        onClick={handleVideoClick}
        muted={isMuted}
        playsInline // 移动端内联播放
        preload={disablePreload ? "none" : currentPreload} // 🚀 动态预加载：悬停时自动缓冲
        crossOrigin="anonymous"
        aria-label={alt || videoTitle || '视频播放器'}
        style={{
          // 智能回退：使用 CSS 背景图确保缩略图显示
          backgroundImage: optimalPoster ? `url(${optimalPoster})` : undefined,
          backgroundSize: 'cover',
          backgroundPosition: 'center',
          backgroundRepeat: 'no-repeat'
        }}
      />

      {/* 🚀 修复UI渲染：桌面端悬停显示，移动端始终显示播放按钮 */}
      {(
        // 桌面端：悬停时显示（支持自动播放）
        (isHovered && autoPlayOnHover && canHover) ||
        // 移动端或不支持悬停：始终显示播放按钮
        (isMobile && showPlayButton) ||
        // 桌面端不支持自动播放：始终显示播放按钮
        (!autoPlayOnHover && showPlayButton)
      ) && (
        <>
          
          {/* 🚀 中央播放按钮：只在暂停状态显示，播放状态隐藏 */}
          {!isBuffering && showPlayButton && !isCurrentlyPlaying(playerId) && !isPendingPlay(playerId) && (
            <div
              className="absolute inset-0 flex items-center justify-center cursor-pointer transition-opacity duration-200 z-10"
              onClick={handlePlayPause}
              onTouchStart={(e) => {
                // 🔧 移动端触摸优化：避免重复触发缓冲状态
                if (isMobile) {
                  const video = videoRef.current
                  if (video) {
                    // 设置触摸状态标记，防止touch和click事件冲突
                    (video as any).__touchInProgress = true
                    // 250ms后清除触摸状态
                    setTimeout(() => {
                      // 🔧 修复：检查组件是否仍然挂载
                      if (!isMountedRef.current) return
                      (video as any).__touchInProgress = false
                    }, 250)
                  }
                  
                  // 🔧 修复：检查组件是否仍然挂载
                  if (!isMountedRef.current) return
                  
                  safeSetState(setShowControls, true, 'showControls')
                  safeSetState(setHasInteracted, true, 'hasInteracted')
                  // 渐进式预加载：仅在需要时切换到auto
                  if (currentPreload !== 'auto' && !isBuffering) {
                    safeSetState(setCurrentPreload, 'auto', 'currentPreload')
                  }
                  // 🚀 避免重复设置缓冲状态，让handleLoadStart统一管理
                  console.log('[SimpleVideoPlayer] 触摸开始，准备播放')
                }
              }}
            >
              {/* 🎯 标准视频播放器行为：暂停时显示播放按钮，播放时隐藏按钮 */}
              <div className="h-12 w-12 md:h-14 md:w-14 bg-black/60 rounded-full flex items-center justify-center backdrop-blur-sm border border-white/20 hover:bg-black/80 transition-all duration-200">
                <Play className="h-6 w-6 md:h-8 md:w-8 text-white" />
              </div>
            </div>
          )}
        </>
      )}
      
      {/* 🚀 简单的半透明圆环缓冲进度指示器 - 与播放按钮尺寸一致 */}
      {isBuffering && (
        <div className="absolute inset-0 flex items-center justify-center z-10">
          <div className="relative h-12 w-12 md:h-14 md:w-14 flex items-center justify-center">
            {/* 半透明黑色圆形背景 - 与播放按钮边框厚度一致 */}
            <div className="absolute inset-0 h-12 w-12 md:h-14 md:w-14 bg-black/60 rounded-full border border-white/20 z-0"></div>
            
            {/* 进度圆环 */}
            <svg className="absolute inset-0 h-12 w-12 md:h-14 md:w-14 transform -rotate-90 z-10" viewBox="0 0 48 48">
              <circle
                cx="24"
                cy="24"
                r="22"
                fill="none"
                stroke="white"
                strokeWidth="2"
                strokeOpacity="0.8"
                strokeLinecap="round"
                strokeDasharray={138.23} // 2π × 22 ≈ 138.23
                strokeDashoffset={138.23 - (138.23 * uiProgress) / 100}
                className="transition-all duration-300"
              />
            </svg>
            
            {/* 中心百分比文字 - 显示在最前面 */}
            <div className="relative z-20 text-white text-xs md:text-sm font-medium">
              {Math.round(uiProgress)}%
            </div>
          </div>
        </div>
      )}
      
      {/* 播放控制栏 - 悬停且有视频时显示（无论播放还是暂停） */}
      {showControls && duration > 0 && (
        <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent">
          {/* 进度条区域 */}
          <div className="px-4 pt-4 pb-2">
            <div 
              className="relative w-full h-1 bg-white/30 rounded-full cursor-pointer group/progress"
              onClick={handleProgressClick}
            >
              {/* 播放进度 */}
              <div 
                className="absolute left-0 top-0 h-full bg-white rounded-full transition-all duration-150"
                style={{ width: `${duration > 0 ? (currentTime / duration) * 100 : 0}%` }}
              />
              {/* 悬停时的进度点 */}
              <div 
                className="absolute top-1/2 w-3 h-3 bg-white rounded-full shadow-md -translate-y-1/2 
                          opacity-0 group-hover/progress:opacity-100 transition-opacity"
                style={{ left: `calc(${duration > 0 ? (currentTime / duration) * 100 : 0}% - 6px)` }}
              />
            </div>
          </div>
          
          {/* 控制按钮区域 */}
          <div className="flex items-center justify-between px-4 pb-3">
            {/* 左侧控制组 */}
            <div className="flex items-center gap-2">
              {/* 🚀 播放/暂停按钮 - 根据播放状态显示不同图标 */}
              <button
                onClick={handlePlayPause}
                className="flex items-center justify-center w-8 h-8 text-white hover:bg-white/20 
                         active:bg-white/40 active:scale-95 rounded-full transition-all duration-150
                         touch-manipulation select-none"
                aria-label={isCurrentlyPlaying(playerId) ? "暂停" : "播放"}
                style={{ 
                  WebkitTapHighlightColor: 'transparent',
                  userSelect: 'none',
                  touchAction: 'manipulation'
                }}
              >
                {isCurrentlyPlaying(playerId) ? (
                  <Pause className="h-4 w-4" />
                ) : (
                  <Play className="h-4 w-4" />
                )}
              </button>
              
              {/* 静音控制按钮 */}
              <button
                onClick={handleMuteToggle}
                className="flex items-center justify-center w-8 h-8 text-white hover:bg-white/20 
                         active:bg-white/40 active:scale-95 rounded-full transition-all duration-150
                         touch-manipulation select-none"
                aria-label={isMuted ? '取消静音' : '静音'}
                style={{ 
                  WebkitTapHighlightColor: 'transparent',
                  userSelect: 'none',
                  touchAction: 'manipulation'
                }}
              >
                {isMuted ? (
                  <VolumeX className="h-4 w-4" />
                ) : (
                  <Volume2 className="h-4 w-4" />
                )}
              </button>
            </div>
            
            {/* 右侧控制组 */}
            <div className="flex items-center gap-0.5">
              {/* 时间显示 - 细字体，位于全屏按钮左侧 */}
              <div className="text-white text-xs font-light font-sans">
                {formatTime(currentTime)} / {formatTime(duration)}
              </div>
              
              {/* 全屏按钮 - 位于最右侧 */}
              <button
                onClick={toggleFullscreen}
                className="flex items-center justify-center w-8 h-8 text-white hover:bg-white/20 
                         active:bg-white/40 active:scale-95 rounded-full transition-all duration-150
                         touch-manipulation select-none"
                aria-label={getFullscreenTooltip(isFullscreen)}
                title={getFullscreenTooltip(isFullscreen)}
                style={{ 
                  WebkitTapHighlightColor: 'transparent',
                  userSelect: 'none',
                  touchAction: 'manipulation'
                }}
              >
                {isFullscreen ? (
                  <Minimize className="h-4 w-4" />
                ) : (
                  <Maximize className="h-4 w-4" />
                )}
              </button>
            </div>
          </div>
        </div>
      )}

    </div>
  )
}

// 轻量版播放器（LightVideoPlayer）已移除，避免重复实现与维护负担
