<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvasæ ¼å¼å…¼å®¹æ€§æµ‹è¯•</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
        }
        .success { background: #e6ffed; border: 1px solid #28a745; }
        .warning { background: #fff3cd; border: 1px solid #ffc107; }
        .error { background: #ffe6e6; border: 1px solid #dc3545; }
        .info { background: #e6f3ff; border: 1px solid #007bff; }
        pre {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <h1>ğŸ” Canvasæ ¼å¼å…¼å®¹æ€§æµ‹è¯•</h1>
    <p>æµ‹è¯•ä¸åŒæµè§ˆå™¨å’Œè®¾å¤‡å¯¹Canvasè¾“å‡ºæ ¼å¼çš„æ”¯æŒæƒ…å†µï¼Œæ‰¾å‡ºPNGç¼©ç•¥å›¾äº§ç”Ÿçš„åŸå› </p>

    <div class="test-container">
        <h2>ğŸ“Š æµè§ˆå™¨ä¿¡æ¯</h2>
        <div id="browser-info"></div>
    </div>

    <div class="test-container">
        <h2>ğŸ¨ Canvasæ ¼å¼æ”¯æŒæµ‹è¯•</h2>
        <div id="format-support"></div>
    </div>

    <div class="test-container">
        <h2>âš¡ Canvasé»˜è®¤è¾“å‡ºæ ¼å¼æµ‹è¯•</h2>
        <div id="default-format"></div>
    </div>

    <div class="test-container">
        <h2>ğŸ“¸ æ¨¡æ‹Ÿç¼©ç•¥å›¾ç”Ÿæˆæµ‹è¯•</h2>
        <div id="thumbnail-test"></div>
    </div>

    <div class="test-container">
        <h2>ğŸ”¬ WebPæ”¯æŒæ·±åº¦æµ‹è¯•</h2>
        <div id="webp-deep-test"></div>
    </div>

    <script>
        // æ˜¾ç¤ºæµè§ˆå™¨ä¿¡æ¯
        function showBrowserInfo() {
            const info = {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                language: navigator.language,
                cookieEnabled: navigator.cookieEnabled,
                onLine: navigator.onLine,
                vendor: navigator.vendor || 'Unknown',
                product: navigator.product || 'Unknown'
            }
            
            document.getElementById('browser-info').innerHTML = 
                `<pre>${JSON.stringify(info, null, 2)}</pre>`
        }

        // æµ‹è¯•Canvasæ ¼å¼æ”¯æŒ
        async function testFormatSupport() {
            const results = []
            const canvas = document.createElement('canvas')
            canvas.width = 100
            canvas.height = 100
            const ctx = canvas.getContext('2d')
            
            // ç»˜åˆ¶æµ‹è¯•å†…å®¹
            ctx.fillStyle = '#667eea'
            ctx.fillRect(0, 0, 100, 100)
            ctx.fillStyle = '#ffffff'
            ctx.fillText('TEST', 30, 50)

            const formats = [
                { type: 'image/webp', name: 'WebP' },
                { type: 'image/jpeg', name: 'JPEG' },
                { type: 'image/png', name: 'PNG' },
                { type: 'image/bmp', name: 'BMP' },
                { type: 'image/gif', name: 'GIF' }
            ]

            for (const format of formats) {
                try {
                    // æµ‹è¯•toDataURLæ”¯æŒ
                    const dataUrl = canvas.toDataURL(format.type, 0.8)
                    const actualFormat = dataUrl.split(';')[0].split(':')[1]
                    
                    results.push({
                        requested: format.name,
                        requestedType: format.type,
                        actualType: actualFormat,
                        supported: actualFormat === format.type,
                        size: Math.round(dataUrl.length / 1024) + ' KB',
                        preview: dataUrl.substring(0, 60) + '...'
                    })
                } catch (error) {
                    results.push({
                        requested: format.name,
                        requestedType: format.type,
                        error: error.message,
                        supported: false
                    })
                }
            }

            // æµ‹è¯•toBlobæ”¯æŒ
            for (const format of formats) {
                try {
                    await new Promise((resolve, reject) => {
                        canvas.toBlob((blob) => {
                            if (blob) {
                                const result = results.find(r => r.requestedType === format.type)
                                if (result) {
                                    result.blobSupported = true
                                    result.blobType = blob.type
                                    result.blobSize = Math.round(blob.size / 1024) + ' KB'
                                }
                            } else {
                                const result = results.find(r => r.requestedType === format.type)
                                if (result) {
                                    result.blobSupported = false
                                    result.blobError = 'Blob creation failed'
                                }
                            }
                            resolve()
                        }, format.type, 0.8)
                    })
                } catch (error) {
                    const result = results.find(r => r.requestedType === format.type)
                    if (result) {
                        result.blobSupported = false
                        result.blobError = error.message
                    }
                }
            }

            // æ˜¾ç¤ºç»“æœ
            let html = '<table border="1" style="border-collapse: collapse; width: 100%;">'
            html += '<tr><th>æ ¼å¼</th><th>toDataURL</th><th>å®é™…ç±»å‹</th><th>toBlob</th><th>å¤§å°</th><th>æ”¯æŒçŠ¶æ€</th></tr>'
            
            results.forEach(result => {
                const status = result.supported ? 
                    '<span style="color: green;">âœ… æ”¯æŒ</span>' : 
                    '<span style="color: red;">âŒ ä¸æ”¯æŒ</span>'
                
                const blobStatus = result.blobSupported === true ? 
                    '<span style="color: green;">âœ…</span>' : 
                    result.blobSupported === false ? 
                    '<span style="color: red;">âŒ</span>' : 
                    '<span style="color: gray;">?</span>'

                html += `<tr>
                    <td>${result.requested}</td>
                    <td>${result.actualType || result.error || 'Unknown'}</td>
                    <td>${result.actualType === result.requestedType ? 'âœ…' : 'âŒ'}</td>
                    <td>${blobStatus}</td>
                    <td>${result.size || result.blobSize || 'N/A'}</td>
                    <td>${status}</td>
                </tr>`
            })
            html += '</table>'

            document.getElementById('format-support').innerHTML = html
            return results
        }

        // æµ‹è¯•Canvasé»˜è®¤è¾“å‡º
        function testDefaultFormat() {
            const canvas = document.createElement('canvas')
            canvas.width = 50
            canvas.height = 50
            const ctx = canvas.getContext('2d')
            
            // ç»˜åˆ¶ç®€å•å†…å®¹
            ctx.fillStyle = '#ff0000'
            ctx.fillRect(0, 0, 50, 50)

            // æµ‹è¯•æ— å‚æ•°è°ƒç”¨
            const defaultOutput = canvas.toDataURL()
            const defaultType = defaultOutput.split(';')[0].split(':')[1]

            // æµ‹è¯•è´¨é‡å‚æ•°
            const qualityOutput = canvas.toDataURL(undefined, 0.8)
            const qualityType = qualityOutput.split(';')[0].split(':')[1]

            const result = `
                <div class="result info">
                    <strong>é»˜è®¤æ ¼å¼æµ‹è¯•ç»“æœ:</strong><br>
                    â€¢ toDataURL(): ${defaultType}<br>
                    â€¢ toDataURL(undefined, 0.8): ${qualityType}<br>
                    â€¢ é»˜è®¤æ ¼å¼å¤§å°: ${Math.round(defaultOutput.length / 1024)} KB<br>
                    â€¢ è´¨é‡å‚æ•°å¤§å°: ${Math.round(qualityOutput.length / 1024)} KB<br>
                    <br>
                    <strong>å…³é”®å‘ç°:</strong> 
                    ${defaultType === 'image/png' ? 
                        '<span style="color: red;">âš ï¸ é»˜è®¤è¾“å‡ºPNGæ ¼å¼ - è¿™å¯èƒ½æ˜¯PNGç¼©ç•¥å›¾çš„æºå¤´ï¼</span>' : 
                        '<span style="color: green;">âœ… é»˜è®¤è¾“å‡ºéPNGæ ¼å¼</span>'
                    }
                </div>
            `

            document.getElementById('default-format').innerHTML = result
        }

        // æ¨¡æ‹Ÿç¼©ç•¥å›¾ç”Ÿæˆ
        async function testThumbnailGeneration() {
            const results = []
            
            // åˆ›å»ºæ¨¡æ‹Ÿè§†é¢‘Canvas
            const videoCanvas = document.createElement('canvas')
            videoCanvas.width = 960
            videoCanvas.height = 540
            const videoCtx = videoCanvas.getContext('2d')
            
            // ç»˜åˆ¶æ¨¡æ‹Ÿè§†é¢‘å¸§
            const gradient = videoCtx.createLinearGradient(0, 0, 960, 540)
            gradient.addColorStop(0, '#667eea')
            gradient.addColorStop(1, '#764ba2')
            videoCtx.fillStyle = gradient
            videoCtx.fillRect(0, 0, 960, 540)
            
            // æ·»åŠ æ–‡å­—
            videoCtx.fillStyle = 'white'
            videoCtx.font = '48px Arial'
            videoCtx.textAlign = 'center'
            videoCtx.fillText('æ¨¡æ‹Ÿè§†é¢‘å¸§', 480, 270)

            // æµ‹è¯•ä¸åŒç”Ÿæˆæ–¹å¼
            const tests = [
                {
                    name: 'æ— å‚æ•° toDataURL()',
                    test: () => videoCanvas.toDataURL()
                },
                {
                    name: 'WebPæ ¼å¼',
                    test: () => videoCanvas.toDataURL('image/webp', 0.95)
                },
                {
                    name: 'JPEGæ ¼å¼',
                    test: () => videoCanvas.toDataURL('image/jpeg', 0.95)
                },
                {
                    name: 'PNGæ ¼å¼',
                    test: () => videoCanvas.toDataURL('image/png')
                }
            ]

            for (const test of tests) {
                try {
                    const result = test.test()
                    const actualType = result.split(';')[0].split(':')[1]
                    const size = Math.round(result.length * 0.75 / 1024) // ä¼°ç®—å®é™…å¤§å°
                    
                    results.push({
                        name: test.name,
                        actualType: actualType,
                        size: size + ' KB',
                        success: true,
                        preview: result.substring(0, 60) + '...'
                    })
                } catch (error) {
                    results.push({
                        name: test.name,
                        error: error.message,
                        success: false
                    })
                }
            }

            // æµ‹è¯•WebPæ”¯æŒæ£€æµ‹
            const webpSupported = await new Promise((resolve) => {
                const canvas = document.createElement('canvas')
                canvas.width = 1
                canvas.height = 1
                
                canvas.toBlob((blob) => {
                    resolve(blob !== null)
                }, 'image/webp')
            })

            let html = `
                <div class="result ${webpSupported ? 'success' : 'warning'}">
                    <strong>WebPæ”¯æŒæ£€æµ‹:</strong> ${webpSupported ? 'âœ… æ”¯æŒ' : 'âŒ ä¸æ”¯æŒ'}
                </div>
            `

            html += '<table border="1" style="border-collapse: collapse; width: 100%; margin-top: 10px;">'
            html += '<tr><th>æµ‹è¯•ç±»å‹</th><th>å®é™…æ ¼å¼</th><th>å¤§å°</th><th>çŠ¶æ€</th></tr>'
            
            results.forEach(result => {
                const statusClass = result.success ? 'success' : 'error'
                html += `<tr class="${statusClass}">
                    <td>${result.name}</td>
                    <td>${result.actualType || 'N/A'}</td>
                    <td>${result.size || 'N/A'}</td>
                    <td>${result.success ? 'âœ…' : 'âŒ ' + result.error}</td>
                </tr>`
            })
            html += '</table>'

            // åˆ†æç»“æœ
            const pngResults = results.filter(r => r.actualType === 'image/png')
            if (pngResults.length > 0) {
                html += `
                    <div class="result warning" style="margin-top: 15px;">
                        <strong>ğŸš¨ PNGç”Ÿæˆåˆ†æ:</strong><br>
                        å‘ç° ${pngResults.length} ç§æƒ…å†µä¼šäº§ç”ŸPNGæ ¼å¼:<br>
                        ${pngResults.map(r => `â€¢ ${r.name} â†’ ${r.actualType}`).join('<br>')}
                    </div>
                `
            }

            document.getElementById('thumbnail-test').innerHTML = html
        }

        // WebPæ”¯æŒæ·±åº¦æµ‹è¯•
        async function testWebPDeepSupport() {
            const tests = []
            
            // æµ‹è¯•1: åŸºç¡€toBlob WebPæ”¯æŒ
            const test1 = await new Promise((resolve) => {
                const canvas = document.createElement('canvas')
                canvas.width = 100
                canvas.height = 100
                const ctx = canvas.getContext('2d')
                ctx.fillStyle = '#ff0000'
                ctx.fillRect(0, 0, 100, 100)
                
                canvas.toBlob((blob) => {
                    resolve({
                        name: 'toBlob WebPåŸºç¡€æ”¯æŒ',
                        result: blob !== null,
                        details: blob ? `æˆåŠŸç”Ÿæˆï¼Œç±»å‹: ${blob.type}, å¤§å°: ${blob.size}å­—èŠ‚` : 'ç”Ÿæˆå¤±è´¥'
                    })
                }, 'image/webp', 0.8)
            })
            tests.push(test1)

            // æµ‹è¯•2: toDataURL WebPæ”¯æŒ
            try {
                const canvas = document.createElement('canvas')
                canvas.width = 100
                canvas.height = 100
                const ctx = canvas.getContext('2d')
                ctx.fillStyle = '#00ff00'
                ctx.fillRect(0, 0, 100, 100)
                
                const dataUrl = canvas.toDataURL('image/webp', 0.8)
                const actualType = dataUrl.split(';')[0].split(':')[1]
                
                tests.push({
                    name: 'toDataURL WebPæ”¯æŒ',
                    result: actualType === 'image/webp',
                    details: `è¯·æ±‚WebPï¼Œå®é™…å¾—åˆ°: ${actualType}`
                })
            } catch (error) {
                tests.push({
                    name: 'toDataURL WebPæ”¯æŒ',
                    result: false,
                    details: `é”™è¯¯: ${error.message}`
                })
            }

            // æµ‹è¯•3: ä¸åŒè´¨é‡å‚æ•°çš„WebP
            const qualityTests = [0.1, 0.5, 0.8, 0.95]
            for (const quality of qualityTests) {
                try {
                    const canvas = document.createElement('canvas')
                    canvas.width = 100
                    canvas.height = 100
                    const ctx = canvas.getContext('2d')
                    ctx.fillStyle = `hsl(${Math.random() * 360}, 50%, 50%)`
                    ctx.fillRect(0, 0, 100, 100)
                    
                    const dataUrl = canvas.toDataURL('image/webp', quality)
                    const actualType = dataUrl.split(';')[0].split(':')[1]
                    const size = Math.round(dataUrl.length * 0.75 / 1024)
                    
                    tests.push({
                        name: `WebPè´¨é‡${quality}`,
                        result: actualType === 'image/webp',
                        details: `å®é™…: ${actualType}, å¤§å°: ${size}KB`
                    })
                } catch (error) {
                    tests.push({
                        name: `WebPè´¨é‡${quality}`,
                        result: false,
                        details: `é”™è¯¯: ${error.message}`
                    })
                }
            }

            // æ˜¾ç¤ºç»“æœ
            let html = '<table border="1" style="border-collapse: collapse; width: 100%;">'
            html += '<tr><th>æµ‹è¯•é¡¹ç›®</th><th>ç»“æœ</th><th>è¯¦ç»†ä¿¡æ¯</th></tr>'
            
            tests.forEach(test => {
                const statusClass = test.result ? 'success' : 'error'
                html += `<tr class="${statusClass}">
                    <td>${test.name}</td>
                    <td>${test.result ? 'âœ… æˆåŠŸ' : 'âŒ å¤±è´¥'}</td>
                    <td>${test.details}</td>
                </tr>`
            })
            html += '</table>'

            // æ€»ç»“åˆ†æ
            const webpSupported = tests.some(t => t.result && t.name.includes('WebP'))
            html += `
                <div class="result ${webpSupported ? 'success' : 'error'}" style="margin-top: 15px;">
                    <strong>ğŸ” WebPæ”¯æŒæ€»ç»“:</strong><br>
                    ${webpSupported ? 
                        'âœ… æµè§ˆå™¨æ”¯æŒWebPæ ¼å¼ï¼ŒPNGç¼©ç•¥å›¾å¯èƒ½ç”±å…¶ä»–åŸå› äº§ç”Ÿ' : 
                        'âŒ æµè§ˆå™¨ä¸æ”¯æŒWebPï¼Œå¯èƒ½å›é€€åˆ°PNGæ ¼å¼'
                    }
                </div>
            `

            document.getElementById('webp-deep-test').innerHTML = html
        }

        // è¿è¡Œæ‰€æœ‰æµ‹è¯•
        async function runAllTests() {
            console.log('ğŸš€ å¼€å§‹Canvasæ ¼å¼å…¼å®¹æ€§æµ‹è¯•...')
            
            showBrowserInfo()
            await testFormatSupport()
            testDefaultFormat()
            await testThumbnailGeneration()
            await testWebPDeepSupport()
            
            console.log('âœ… æ‰€æœ‰æµ‹è¯•å®Œæˆ')
        }

        // é¡µé¢åŠ è½½åè¿è¡Œæµ‹è¯•
        document.addEventListener('DOMContentLoaded', runAllTests)
    </script>
</body>
</html>